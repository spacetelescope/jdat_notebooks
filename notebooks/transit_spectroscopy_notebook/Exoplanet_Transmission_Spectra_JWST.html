<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator"/>
  <title>
   BOTS Time Series Observations — STScI JDAT Notebooks
  </title>
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
  <link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
  <link href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
  <link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
  <link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
  <link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" rel="stylesheet" type="text/css"/>
  <link href="../../_static/togglebutton.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/copybutton.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/mystnb.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/sphinx-thebe.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/main.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" rel="stylesheet" type="text/css"/>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf" rel="preload"/>
  <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js">
  </script>
  <script src="../../_static/jquery.js">
  </script>
  <script src="../../_static/underscore.js">
  </script>
  <script src="../../_static/doctools.js">
  </script>
  <script src="../../_static/clipboard.min.js">
  </script>
  <script src="../../_static/copybutton.js">
  </script>
  <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411">
  </script>
  <script>
   let toggleHintShow = 'Click to show';
  </script>
  <script>
   let toggleHintHide = 'Click to hide';
  </script>
  <script>
   let toggleOpenOnPrint = 'true';
  </script>
  <script src="../../_static/togglebutton.js">
  </script>
  <script>
   var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';
  </script>
  <script src="../../_static/design-tabs.js">
  </script>
  <script>
   const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
  </script>
  <script async="async" src="../../_static/sphinx-thebe.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js">
  </script>
  <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js">
  </script>
  <script>
   window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}
  </script>
  <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <link href="../../genindex.html" rel="index" title="Index"/>
  <link href="../../search.html" rel="search" title="Search"/>
  <link href="../mos-spectroscopy/MOSspec_sv06_revised.html" rel="prev" title="MOS Spectroscopy of Extragalactic Field"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <meta content="None" name="docsearch:language"/>
  <!-- Google Analytics -->
  <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-D46G4HKJY3">
  </script>
  <script>
   window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-D46G4HKJY3');
  </script>
 </head>
 <body data-offset="60" data-spy="scroll" data-target="#bd-toc-nav">
  <!-- Checkboxes to toggle the left sidebar -->
  <input aria-label="Toggle navigation sidebar" class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
  <label class="overlay overlay-navbar" for="__navigation">
   <div class="visually-hidden">
    Toggle navigation sidebar
   </div>
  </label>
  <!-- Checkboxes to toggle the in-page toc -->
  <input aria-label="Toggle in-page Table of Contents" class="sidebar-toggle" id="__page-toc" name="__page-toc" type="checkbox"/>
  <label class="overlay overlay-pagetoc" for="__page-toc">
   <div class="visually-hidden">
    Toggle in-page Table of Contents
   </div>
  </label>
  <!-- Headers at the top -->
  <div class="announcement header-item noprint">
  </div>
  <div class="header header-item noprint">
  </div>
  <div class="container-fluid" id="banner">
  </div>
  <div class="container-xl">
   <div class="row">
    <!-- Sidebar -->
    <div class="bd-sidebar noprint" id="site-navigation">
     <div class="bd-sidebar__content">
      <div class="bd-sidebar__top">
       <div class="navbar-brand-box">
        <a class="navbar-brand text-wrap" href="../../index.html">
         <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
         <img alt="logo" class="logo" src="../../_static/stsci_logo2.png"/>
         <h1 class="site-logo" id="site-title">
          STScI JDAT Notebooks
         </h1>
        </a>
       </div>
       <form action="../../search.html" class="bd-search d-flex align-items-center" method="get">
        <i class="icon fas fa-search">
        </i>
        <input aria-label="Search this book..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search this book..." type="search"/>
       </form>
       <nav aria-label="Main" class="bd-links" id="bd-docs-nav">
        <div class="bd-toc-item active">
         <ul class="nav bd-sidenav bd-sidenav__home-link">
          <li class="toctree-l1">
           <a class="reference internal" href="../../intro.html">
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           General
          </span>
         </p>
         <ul class="nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../../index.html">
            Home
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../../install.html">
            Installation
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           Cross-Instrument
          </span>
         </p>
         <ul class="nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../asdf_example/asdf_example.html">
            ASDF Example
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../background_estimation_imaging/Imaging_Sky_Background_Estimation.html">
            Complex 2D Background
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../composite_model_fitting/specfit_demo_3.html">
            Composite Model Spectral Fitting
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRSpec_MAST_Query/NIRSpec_MAST_Query.html">
            MAST Query
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../specviz_notebookGUI_interaction/specviz_notebook_gui_interaction_redshift.html">
            Specviz Simple Demo
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../cube_fitting/cube_fitting.html">
            IFU Cube Line Maps
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           MIRI
          </span>
         </p>
         <ul class="nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../MRS_Mstar_analysis/JWST_Mstar_dataAnalysis_runpipeline.html">
            MRS Mstar - Run Pipeline
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../MRS_Mstar_analysis/JWST_Mstar_dataAnalysis_PointSourceDetectorBasedExtraction.html">
            MRS Detector Based Extraction
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../MRS_Mstar_analysis/JWST_Mstar_dataAnalysis_analysis.html">
            MRS Mstar - Data Analysis
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../MIRI_IFU_YSOs_in_the_LMC/isha_nayak_ysos_in_the_lmc.html">
            IFU of YSOs in LMC
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../MIRI_LRS_spectral_extraction/miri_lrs_spectral_extraction.html">
            LRS Optimal Spectral Extraction
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           NIRCam
          </span>
         </p>
         <ul class="nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../aperture_photometry/NIRCam_Aperture_Photometry_Example.html">
            Point Source Aperture Photometry
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRCam_photometry/NIRCam_multiband_photometry.html">
            Extended Aperture Photometry
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRCam_PSF-matched_photometry/NIRCam_PSF_matched_multiband_photometry.html">
            Cross-Filter PSF Matching
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../psf_photometry/NIRCam_PSF_Photometry_Example.html">
            PSF Photometry
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           NIRISS
          </span>
         </p>
         <ul class="nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRISS_WFSS_postpipeline/00_Optimal_extraction.html">
            WFSS Spectra - Optimal Extraction
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRISS_WFSS_postpipeline/01_Combine_and_normalize_1D_spectra.html">
            WFSS Spectra - Combine and Normalize 1D Spectra
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRISS_WFSS_postpipeline/02_Cross_correlation_template.html">
            WFSS Spectra - Cross-Correlation Template
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../NIRISS_WFSS_postpipeline/03_Spatially_resolved_emission_line_map.html">
            WFSS Spectra - Emission Line Map
           </a>
          </li>
         </ul>
         <p aria-level="2" class="caption" role="heading">
          <span class="caption-text">
           NIRSpec
          </span>
         </p>
         <ul class="current nav bd-sidenav">
          <li class="toctree-l1">
           <a class="reference internal" href="../IFU_cube_continuum_fit/NGC4151_FeII_ContinuumFit.html">
            IFU Cube Fitting
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../ifu_optimal/ifu_optimal.html">
            IFU Optimal Spectral Extraction
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../optimal_extraction/Spectral_Extraction-static.html">
            MOS Optimal Extraction
           </a>
          </li>
          <li class="toctree-l1">
           <a class="reference internal" href="../mos-spectroscopy/MOSspec_sv06_revised.html">
            MOS Spectroscopy of Extragalactic Field
           </a>
          </li>
          <li class="toctree-l1 current active">
           <a class="current reference internal" href="#">
            BOTS Time Series Observations
           </a>
          </li>
         </ul>
        </div>
       </nav>
      </div>
      <div class="bd-sidebar__bottom">
       <!-- To handle the deprecated key -->
       <div class="navbar_extra_footer">
        Powered by
        <a href="https://jupyterbook.org">
         Jupyter Book
        </a>
       </div>
      </div>
     </div>
     <div id="rtd-footer-container">
     </div>
    </div>
    <!-- A tiny helper pixel to detect if we've scrolled -->
    <div class="sbt-scroll-pixel-helper">
    </div>
    <!-- Main content -->
    <div class="col py-0 content-container">
     <div class="header-article row sticky-top noprint">
      <div class="col py-1 d-flex header-article-main">
       <div class="header-article__left">
        <label class="headerbtn" data-placement="right" data-toggle="tooltip" for="__navigation" title="Toggle navigation">
         <span class="headerbtn__icon-container">
          <i class="fas fa-bars">
          </i>
         </span>
        </label>
       </div>
       <div class="header-article__right">
        <div class="menu-dropdown menu-dropdown-launch-buttons">
         <button aria-label="Launch interactive content" class="headerbtn menu-dropdown__trigger">
          <i class="fas fa-rocket">
          </i>
         </button>
         <div class="menu-dropdown__content">
          <ul>
           <li>
            <button class="headerbtn headerbtn-launch-thebe" data-placement="left" data-toggle="tooltip" onclick="initThebeSBT()" title="Launch Thebe">
             <span class="headerbtn__icon-container">
              <i class="fas fa-play">
              </i>
             </span>
             <span class="headerbtn__text-container">
              Live Code
             </span>
            </button>
           </li>
          </ul>
         </div>
        </div>
        <button class="headerbtn" data-placement="bottom" data-toggle="tooltip" onclick="toggleFullScreen()" title="Fullscreen mode">
         <span class="headerbtn__icon-container">
          <i class="fas fa-expand">
          </i>
         </span>
        </button>
        <div class="menu-dropdown menu-dropdown-repository-buttons">
         <button aria-label="Source repositories" class="headerbtn menu-dropdown__trigger">
          <i class="fab fa-github">
          </i>
         </button>
         <div class="menu-dropdown__content">
          <ul>
           <li>
            <a class="headerbtn" data-placement="left" data-toggle="tooltip" href="https://github.com/spacetelescope/jdat_notebooks/" title="Source repository">
             <span class="headerbtn__icon-container">
              <i class="fab fa-github">
              </i>
             </span>
             <span class="headerbtn__text-container">
              repository
             </span>
            </a>
           </li>
           <li>
            <a class="headerbtn" data-placement="left" data-toggle="tooltip" href="https://github.com/spacetelescope/jdat_notebooks//issues/new?title=Issue%20on%20page%20%2Fnotebooks/transit_spectroscopy_notebook/Exoplanet_Transmission_Spectra_JWST.html&amp;body=Your%20issue%20content%20here." title="Open an issue">
             <span class="headerbtn__icon-container">
              <i class="fas fa-lightbulb">
              </i>
             </span>
             <span class="headerbtn__text-container">
              open issue
             </span>
            </a>
           </li>
          </ul>
         </div>
        </div>
        <div class="menu-dropdown menu-dropdown-download-buttons">
         <button aria-label="Download this page" class="headerbtn menu-dropdown__trigger">
          <i class="fas fa-download">
          </i>
         </button>
         <div class="menu-dropdown__content">
          <ul>
           <li>
            <a class="headerbtn" data-placement="left" data-toggle="tooltip" href="../../_sources/notebooks/transit_spectroscopy_notebook/Exoplanet_Transmission_Spectra_JWST.ipynb" title="Download source file">
             <span class="headerbtn__icon-container">
              <i class="fas fa-file">
              </i>
             </span>
             <span class="headerbtn__text-container">
              .ipynb
             </span>
            </a>
           </li>
           <li>
            <button class="headerbtn" data-placement="left" data-toggle="tooltip" onclick="printPdf(this)" title="Print to PDF">
             <span class="headerbtn__icon-container">
              <i class="fas fa-file-pdf">
              </i>
             </span>
             <span class="headerbtn__text-container">
              .pdf
             </span>
            </button>
           </li>
          </ul>
         </div>
        </div>
        <label class="headerbtn headerbtn-page-toc" for="__page-toc">
         <span class="headerbtn__icon-container">
          <i class="fas fa-list">
          </i>
         </span>
        </label>
       </div>
      </div>
      <!-- Table of contents -->
      <div class="col-md-3 bd-toc show noprint">
       <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list">
        </i>
        Contents
       </div>
       <nav aria-label="Page" id="bd-toc-nav">
        <ul class="visible nav section-nav flex-column">
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#">
           BOTS Time Series Observations
          </a>
          <ul class="visible nav section-nav flex-column">
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#introduction">
             Introduction
            </a>
           </li>
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#load-packages">
             Load packages
            </a>
           </li>
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#setup-parameters">
             Setup Parameters
            </a>
           </li>
          </ul>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#download-and-load-nirspec-data">
           Download and Load NIRSpec data
          </a>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#visualizing-the-2d-spectral-data">
           Visualizing the 2D spectral data
          </a>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#extract-1d-spectra-from-2d-array-of-images">
           Extract 1D spectra from 2D array of images
          </a>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#visualizing-the-1d-spectral-data">
           Visualizing the 1D spectral data
          </a>
          <ul class="visible nav section-nav flex-column">
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#calculate-orbital-phase-and-a-separate-fine-grid-model-used-for-plotting-purposes">
             Calculate Orbital Phase and a separate fine grid model used for plotting purposes
            </a>
           </li>
          </ul>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#dealing-with-systematic-drift-on-the-detector">
           Dealing with Systematic Drift On the Detector
          </a>
          <ul class="visible nav section-nav flex-column">
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#create-arrays-of-the-vectors-used-for-detrending">
             Create arrays of the vectors used for detrending.
            </a>
           </li>
          </ul>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#transit-and-limb-darkening-model-functions">
           Transit and Limb-Darkening Model Functions
          </a>
          <ul class="visible nav section-nav flex-column">
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#now-define-the-transit-model-function">
             Now define the transit model function
            </a>
           </li>
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#now-define-the-function-to-generate-the-transit-light-curve-and-compare-it-to-the-data">
             Now define the function to generate the transit light curve and compare it to the data
            </a>
           </li>
          </ul>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#fit-transit-light-curves">
           FIT Transit Light Curves
          </a>
          <ul class="visible nav section-nav flex-column">
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#setup-wavelengths-to-fit-over">
             Setup Wavelengths to fit over
            </a>
           </li>
           <li class="toc-h2 nav-item toc-entry">
            <a class="reference internal nav-link" href="#loop-over-wavelength-bins-fitting-each-lightcurve">
             Loop Over Wavelength Bins Fitting Each Lightcurve
            </a>
            <ul class="nav section-nav flex-column">
             <li class="toc-h3 nav-item toc-entry">
              <a class="reference internal nav-link" href="#note-this-step-takes-considerable-time-to-complete-20-min-few-minutes-bin">
               Note this step takes considerable time to complete (~20 min, few minutes/bin)
              </a>
             </li>
            </ul>
           </li>
          </ul>
         </li>
         <li class="toc-h1 nav-item toc-entry">
          <a class="reference internal nav-link" href="#plot-measured-exoplanet-transmission-spectrum-vs-injected">
           Plot Measured Exoplanet Transmission Spectrum vs Injected
          </a>
         </li>
        </ul>
       </nav>
      </div>
     </div>
     <div class="article row">
      <div class="col pl-md-3 pl-lg-5 content-container">
       <!-- Table of contents that is only displayed when printing the page -->
       <div class="onlyprint" id="jb-print-docs-body">
        <h1>
         BOTS Time Series Observations
        </h1>
        <!-- Table of contents -->
        <div id="print-main-content">
         <div id="jb-print-toc">
          <div>
           <h2>
            Contents
           </h2>
          </div>
          <nav aria-label="Page">
           <ul class="visible nav section-nav flex-column">
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#">
              BOTS Time Series Observations
             </a>
             <ul class="visible nav section-nav flex-column">
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#introduction">
                Introduction
               </a>
              </li>
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#load-packages">
                Load packages
               </a>
              </li>
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#setup-parameters">
                Setup Parameters
               </a>
              </li>
             </ul>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#download-and-load-nirspec-data">
              Download and Load NIRSpec data
             </a>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#visualizing-the-2d-spectral-data">
              Visualizing the 2D spectral data
             </a>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#extract-1d-spectra-from-2d-array-of-images">
              Extract 1D spectra from 2D array of images
             </a>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#visualizing-the-1d-spectral-data">
              Visualizing the 1D spectral data
             </a>
             <ul class="visible nav section-nav flex-column">
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#calculate-orbital-phase-and-a-separate-fine-grid-model-used-for-plotting-purposes">
                Calculate Orbital Phase and a separate fine grid model used for plotting purposes
               </a>
              </li>
             </ul>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#dealing-with-systematic-drift-on-the-detector">
              Dealing with Systematic Drift On the Detector
             </a>
             <ul class="visible nav section-nav flex-column">
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#create-arrays-of-the-vectors-used-for-detrending">
                Create arrays of the vectors used for detrending.
               </a>
              </li>
             </ul>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#transit-and-limb-darkening-model-functions">
              Transit and Limb-Darkening Model Functions
             </a>
             <ul class="visible nav section-nav flex-column">
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#now-define-the-transit-model-function">
                Now define the transit model function
               </a>
              </li>
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#now-define-the-function-to-generate-the-transit-light-curve-and-compare-it-to-the-data">
                Now define the function to generate the transit light curve and compare it to the data
               </a>
              </li>
             </ul>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#fit-transit-light-curves">
              FIT Transit Light Curves
             </a>
             <ul class="visible nav section-nav flex-column">
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#setup-wavelengths-to-fit-over">
                Setup Wavelengths to fit over
               </a>
              </li>
              <li class="toc-h2 nav-item toc-entry">
               <a class="reference internal nav-link" href="#loop-over-wavelength-bins-fitting-each-lightcurve">
                Loop Over Wavelength Bins Fitting Each Lightcurve
               </a>
               <ul class="nav section-nav flex-column">
                <li class="toc-h3 nav-item toc-entry">
                 <a class="reference internal nav-link" href="#note-this-step-takes-considerable-time-to-complete-20-min-few-minutes-bin">
                  Note this step takes considerable time to complete (~20 min, few minutes/bin)
                 </a>
                </li>
               </ul>
              </li>
             </ul>
            </li>
            <li class="toc-h1 nav-item toc-entry">
             <a class="reference internal nav-link" href="#plot-measured-exoplanet-transmission-spectrum-vs-injected">
              Plot Measured Exoplanet Transmission Spectrum vs Injected
             </a>
            </li>
           </ul>
          </nav>
         </div>
        </div>
       </div>
       <main id="main-content" role="main">
        <div>
         <section class="tex2jax_ignore mathjax_ignore" id="bots-time-series-observations">
          <h1>
           BOTS Time Series Observations
           <a class="headerlink" href="#bots-time-series-observations" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           <strong>
            Use case:
           </strong>
           Bright Object Time Series; extracting exoplanet spectra.
           <br/>
           <strong>
            Data:
           </strong>
           JWST simulated NIRSpec data from ground-based campaign; GJ436b spectra from the Goyal et al. (2018).
           <br/>
           <strong>
            Tools:
           </strong>
           scikit, lmfit, scipy, matplotlip, astropy, pandas.
           <br/>
           <strong>
            Cross-intrument:
           </strong>
           .
           <br/>
           <strong>
            Documentation:
           </strong>
           This notebook is part of a STScI’s larger
           <a class="reference external" href="https://jwst-docs.stsci.edu/jwst-post-pipeline-data-analysis">
            post-pipeline Data Analysis Tools Ecosystem
           </a>
           .
           <br/>
           <strong>
            Author:
           </strong>
           David K. Sing (
           <a class="reference external" href="mailto:dsing%40jhu.edu">
            dsing
            <span>
             @
            </span>
            jhu
            <span>
             .
            </span>
            edu
           </a>
           )
           <br/>
           <strong>
            Last updated:
           </strong>
           2 July 2020
          </p>
          <section id="introduction">
           <h2>
            Introduction
            <a class="headerlink" href="#introduction" title="Permalink to this headline">
             #
            </a>
           </h2>
           <p>
            This notebook uses time series JWST NIRSpec data taken during a ground-based campaign to illustrate extracting exoplanet spectra from time-series observations.
           </p>
           <p>
            The data are derived from the ISIM-CV3, the cryovacuum campaign of the JWST Integrated Science Instrument Module (ISIM), that took place at Goddard Space Flight Center during the winter 2015-2016 (Kimble et al. 2016). The data can be found at
            <a class="reference external" href="https://www.cosmos.esa.int/web/jwst-nirspec/test-data">
             https://www.cosmos.esa.int/web/jwst-nirspec/test-data
            </a>
            , and detailed and insightful report of the data by G. Giardino, S. Birkmann, P. Ferruit, B. Dorner, B. Rauscher can be found here:
            <span class="xref myst">
             ftp://ftp.cosmos.esa.int/jwstlib/ReleasedCV3dataTimeSeries/CV3_TimeSeries_PRM.tgz
            </span>
           </p>
           <p>
            This NIRSpec time series dataset has had a transit light curve injected at the pixel-level, which closely mimics a bright object time series (BOTS) observation of a transiting exoplanet. In this case, a GJ436b spectra from the
            <strong>
             <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2018MNRAS.474.5158G/">
              Goyal et al. (2018)
             </a>
            </strong>
            exoplanet grid was selected (clear atmosphere at solar metallicity).  With an actual NIRSpec dataset, the noise properties of the detector, jitter, and the effects on extracting exoplanet spectra from time-series observations can more accurately simulated.
           </p>
           <p>
            Broadly the aim of this notebook is to work with these time series observations to:
           </p>
           <ol class="simple">
            <li>
             <p>
              Extract 1D spectra from the 2D spectral images.
             </p>
            </li>
            <li>
             <p>
              Define a time series model to fit to the wavelength dependent transit light curve.
             </p>
            </li>
            <li>
             <p>
              Fit each time series wavelength bin of the 1D spectra, measuring the desired quantity
              <span class="math notranslate nohighlight">
               \(R_{pl}(\lambda)/R_{star}\)
              </span>
              .
             </p>
            </li>
            <li>
             <p>
              Produce a measured transmission spectrum that can then be compared to models.
             </p>
            </li>
           </ol>
           <p>
            The example outputs the fit light curves for each spectral bin, along with fitting statistics.
           </p>
          </section>
          <section id="load-packages">
           <h2>
            Load packages
            <a class="headerlink" href="#load-packages" title="Permalink to this headline">
             #
            </a>
           </h2>
           <p>
            This notebook uses packages (matplotlib, astropy, scipy, glob, lmfit, pickle, os, sklearn) which can all be installed in a standard fashion through pip.
           </p>
           <p>
            Several routines to calculate limb-darkening and a transit model were extracted from ExoTiC-ISm
(
            <strong>
             <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2020JOSS....5.2281L/">
              Laginja &amp; Wakeford 2020
             </a>
            </strong>
            ;
            <a class="reference external" href="https://github.com/hrwakeford/ExoTiC-ISM">
             https://github.com/hrwakeford/ExoTiC-ISM
            </a>
            ), and slightly adapted. The full set of stellar models used for the limb-darkening calculation can also be downloaded from ExoTiC-ISM, as this notebook only downloads and loads the single stellar model used to generate the limb darkening.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.backends.backend_pdf import PdfPages
from astropy.utils.data import get_pkg_data_filename, download_file
from astropy.table import Table, Column, MaskedColumn
from astropy.io import fits, ascii
from astropy.modeling.models import custom_model
from astropy.modeling.fitting import LevMarLSQFitter
import astropy.units as u
from scipy.interpolate import interp1d, splev, splrep
import scipy.optimize as opt
from scipy.io import readsav
from scipy import stats
import glob
import lmfit
import pickle
from os import path,mkdir
from sklearn.linear_model import LinearRegression
import warnings
import pandas as pd
import os
import shutil
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
          <section id="setup-parameters">
           <h2>
            Setup Parameters
            <a class="headerlink" href="#setup-parameters" title="Permalink to this headline">
             #
            </a>
           </h2>
           <p>
            Parameters of the fit include directories where the data and limb darkening stellar models are held, along with properties of the planet and star. The stellar and planet values that have been entered here (modeled after GJ436) are the same as was used to model the injected transit.  Note, the 4500K stellar model used to inject the transit was hotter than GJ436A.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>#---------------------------------------------------------
# SETUP  ----------------------------------------------
# Setup directories
save_directory      ='./notebookrun2/'          #local directory to save files to
data_directory      ='./'                       #local data to work with fits files if desired

# Setup Detector Properties &amp; Rednoise measurement timescale 
gain               = 1.0  # 2D spectra has already converted to counts, gain of detector is 1.0
binmeasure         = 256  # Binning technique to measure rednoise, choose bin size to evaluate sigma_r
number_of_images   = 8192 # Number of images in the dataset

# Setup Planet Properies
grating    = 'NIRSpecPrism'
ld_model   = '3D'         # 3D/1D stellar model choise (transit was injected with the 3D model)

# Setup Stellar Properies for Limb-Darkening Calculation
Teff     = 4500           # Effective Temperature (K)
logg     = 4.5            # Surface Gravity
M_H      = 0.0            # Stellar Metallicity log_10[M/H]
Rstar    = 0.455          # planet radius (in units of solar radii Run)

#Setup Transit parameters (can get from Nasa exoplanet archive)
t0       = 2454865.084034              # bjd time of inferior conjunction 
per      = 2.64389803                  # orbital period (days) BJD_TDB
rp       = 0.0804                      # planet radius (in units of stellar radii)
a_Rs     = 14.54                       # semi-major axis (input a/Rstar so units of stellar radii)
inc      = 86.858  *(2*np.pi/360)      # orbital inclination (in degrees-&gt;radians)
ecc      = 0.0                         # eccentricity
omega    = 0.0  *(2*np.pi/360)         # longitude of periastron (in degrees-&gt;radians)

rho_star = (3*np.pi)/(6.67259E-8*(per*86400)**2)*(a_Rs)**3     # Stellar Density (g/cm^3) from a/Rs
# a_Rs=(rho_star*6.67259E-8*per_sec*per_sec/(3*np.pi))**(1/3)  # a/Rs from Stellar Density (g/cm^3)
#---------------------------------------------------------
</pre>
              </div>
             </div>
            </div>
           </div>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span># Create local directories
if path.exists(save_directory) == False: mkdir(save_directory)      #Create new directory to save outputs to if needed
if path.exists(save_directory+'3DGrid') == False: mkdir(save_directory+'3DGrid')      #Create new directory to save
limb_dark_directory = save_directory               # point to limb darkeing directory contaning 3DGrid/ directory
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="download-and-load-nirspec-data">
          <h1>
           Download and Load NIRSpec data
           <a class="headerlink" href="#download-and-load-nirspec-data" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           The fits images are loaded, and information including the image date and science spectra are saved.
          </p>
          <p>
           A default flux offset value BZERO is also taken from the header and subtracted from every science frame.
          </p>
          <p>
           Reading in the 2^13 fits files is slow.  To speed things up, we created a pickle file of the for first instance the fits images are loaded.  This 1GB pickle file is loaded instead of reading the fits files if found.
          </p>
          <p>
           Alternatively, the fits files can be downloaded here:
           <a class="reference external" href="https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/Archive.Trace_SLIT_A_1600_SRAD-PRM-PS-6007102143_37803_JLAB88_injected.tar.gz">
            https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/Archive.Trace_SLIT_A_1600_SRAD-PRM-PS-6007102143_37803_JLAB88_injected.tar.gz
           </a>
           .  The images are in a tar.gz archvie, which needs to be un-archived and data_directory variable set to the directory in the SETUP cell above.
          </p>
          <p>
           The cell below downloads the 1GB JWST data pickle file, and several other files needed.
          </p>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>#Download 1GB NIRSpec Data
fn_jw=save_directory+'jwst_data.pickle'
if path.exists(fn_jw) == False:
    fn   = download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/jwst_data.pickle')
    dest = shutil.move(fn,save_directory+'jwst_data.pickle')  
    print('JWST Data Download Complete')

#Download further files needed, move to local directory for easier repeated access
fn_sens= download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/NIRSpec.prism.sensitivity.sav')
dest   = shutil.move(fn_sens,save_directory+'NIRSpec.prism.sensitivity.sav')  #Move files to save_directory

fn_ld  = download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/3DGrid/mmu_t45g45m00v05.flx')
destld = shutil.move(fn_ld,save_directory+'3DGrid/mmu_t45g45m00v05.flx')        
</pre>
             </div>
            </div>
           </div>
          </div>
          <p>
           Loads the Pickle File data.  Alternatly, the data can be read from the original fits files.
          </p>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>if path.exists(fn_jw) == True:
    dbfile = open(fn_jw, 'rb') # for reading also binary mode is important
    jwst_data = pickle.load(dbfile)
    print('Loading JWST data from Pickle File')
    bjd            =jwst_data['bjd']
    wsdata_all     =jwst_data['wsdata_all']
    shx            =jwst_data['shx']
    shy            =jwst_data['shy']
    common_mode    =jwst_data['common_mode']
    all_spec       =jwst_data['all_spec']
    exposure_length=jwst_data['exposure_length']
    dbfile.close()    
    print('Done')
elif path.exists(fn_jw) == False:
    #---------------------------------------------------------
    # load all fits images
    # Arrays created for BJD time, and the white light curve total_counts
    list=glob.glob(data_directory+"*.fits")
    index_of_images=np.arange(number_of_images) #
    bjd=np.zeros((number_of_images))
    exposure_length=np.zeros((number_of_images))
    all_spec=np.zeros((32,512,number_of_images))
    for i in index_of_images:
        img=list[i]
        print(img)
        hdul=fits.open(img)
        #hdul.info()
        bjd_image=hdul[0].header['BJD_TDB']
        BZERO=hdul[0].header['BZERO']        #flux value offset
        bjd[i]=bjd_image
        expleng=hdul[0].header['INTTIME']    #Total integration time for one MULTIACCUM (seconds)
        exposure_length[i]=expleng/86400.    #Total integration time for one MULTIACCUM (days)
        print(bjd[i])
        data = hdul[0].data
        #total counts in image
        #total_counts[i]=gain*np.sum(data[11:18,170:200]-BZERO) #total counts in 12 pix wide aperature around pixel 60 image
        all_spec[:,:,i]=gain*(data-BZERO)     #load all spectra into an array subtract flux value offset
        hdul.close()
    #Sort data
    srt=np.argsort(bjd) #index to sort
    bjd=bjd[srt]
    #total_counts=total_counts[srt]
    exposure_length=exposure_length[srt]
    all_spec[:,:,:]=all_spec[:,:,srt]

    # Get Wavelegnth of Data
    file_wave = download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/JWST_NIRSpec_wavelength_microns.txt')
    f = open(file_wave, 'r')
    wsdata_all = np.genfromtxt(f)
    
    print('wsdata size :',wsdata_all.shape)
    print('Data wavelength Loaded :',wsdata_all)
    print('wsdata new size :',wsdata_all.shape)
    
    #---------------------------------------------------------
    # Read in Detrending parameters
    # Mean of parameter must be 0.0 to be properly normalized
    # Idealy standard deviation of paramter = 1.0
    file_xy=download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/JWST_NIRSpec_Xposs_Yposs_CM_detrending.txt')
    f = open(file_xy, 'r')
    data = np.genfromtxt(f, delimiter=',')
    shx        = data[:,0]
    shy        = data[:,1]
    common_mode= data[:,2]
    
    #Store Data into a pickle file
    jwst_data={'bjd':bjd, 'wsdata_all':wsdata_all, 'shx':shx , 'shy':shy , 'common_mode':common_mode, 'all_spec':all_spec, 'exposure_length':exposure_length}
    dbfile = open('jwst_data.pickle', 'ab') # Its important to use binary mode
    pickle.dump(jwst_data,dbfile)
    dbfile.close()
    #---------------------------------------------------------

    
</pre>
             </div>
            </div>
           </div>
          </div>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="visualizing-the-2d-spectral-data">
          <h1>
           Visualizing the 2D spectral data
           <a class="headerlink" href="#visualizing-the-2d-spectral-data" title="Permalink to this headline">
            #
           </a>
          </h1>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>expnum=2                                           #Choose Exposure number to view

plt.rcParams['figure.figsize'] = [10.0, 3.0]           # Figure dimensions
plt.rcParams['figure.dpi']     = 200                   # Resolution
plt.rcParams['savefig.dpi']    = 200
plt.rcParams['image.aspect']   = 5                     # Aspect ratio (the CCD is quite long!!!)
plt.cmap = plt.cm.magma
plt.cmap.set_bad('k',1.)
plt.rcParams['image.cmap'] = 'magma'                   # Colormap.
plt.rcParams['image.interpolation'] = None
plt.rcParams['image.origin'] = 'lower'
plt.rcParams['font.family'] = "monospace"
plt.rcParams['font.monospace'] = 'DejaVu Sans Mono'

img=all_spec[:,:,expnum]
zeros=np.where(img &lt;= 0)     #Plot on a log scale, so set zero or negitive values to a small number 
img[zeros]=1E-10
fig,axs = plt.subplots()
f=axs.imshow(np.log10(img),vmin=0) #Plot image
plt.xlabel('x-pixel')
plt.ylabel('y-pixel')
axs.yaxis.set_major_locator(ticker.MultipleLocator(5))
axs.yaxis.set_minor_locator(ticker.MultipleLocator(1))
axs.xaxis.set_major_locator(ticker.MultipleLocator(50))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(10))
plt.title('2D NIRSpec Image of Exposure '+str(expnum))
fig.colorbar(f,label='Log$_{10}$ Electron counts',ax=axs)
plt.show()
</pre>
             </div>
            </div>
           </div>
          </div>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="extract-1d-spectra-from-2d-array-of-images">
          <h1>
           Extract 1D spectra from 2D array of images
           <a class="headerlink" href="#extract-1d-spectra-from-2d-array-of-images" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           Ideally, extracting 1D spectra from the 2D images would use optimal aperture extraction along a fit
trace with routines equivalent to IRAF/apall. This functionality is not yet available in astro-py.
          </p>
          <p>
           Several processing steps have already been applied.  The 2D spectra here have been flat field corrected, and 1/f noise has been removed from each pixel by subtracting the median count rate from the un-illuminated pixels along each column (see
           <strong>
            <span class="xref myst">
             Giardino et al.
            </span>
           </strong>
           for more information about 1/f noise).  Each 2D image has also been aligned in the X and Y directions, such that each pixel corresponds to the same wavelength.  As the CV3 test had no requirements for flux stability, the ~1% flux variations from the LED have also been removed.
          </p>
          <p>
           For spectral extraction, the example here simply uses a simple summed box.  The 8192 2D spectra have been
pre-loaded into a numpy array.  The spectra peaks at pixel Y=16. For each column, an aperature sum is taken over Y-axis pixels 11 to 18, which
contains most of the spectrum counts. Wider aperture would add more counts, but also introduces more noise.
          </p>
          <p>
           <strong>
            Further cleaning steps are not done here
           </strong>
          </p>
          <ol class="simple">
           <li>
            <p>
             Ideally, the pixels flagged as bad for various reasons should be cleaned.
            </p>
           </li>
           <li>
            <p>
             Cosmic rays should be identified and removed.
            </p>
           </li>
          </ol>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>all_spec.shape
y_lower = 11                                             # Lower extraction aperature
y_upper = 18                                             # Upper extraction aperature
all_spec_1D=np.sum(all_spec[y_lower:y_upper,:,:],axis=0) # Sum along Y-axis from pixels 11 to 18

#Plot 

plt.rcParams['figure.figsize'] = [10.0, 3.0]           # Figure dimensions
plt.rcParams['figure.dpi']     = 200                   # Resolution
plt.rcParams['savefig.dpi']    = 200
plt.rcParams['image.aspect']   = 5                     # Aspect ratio (the CCD is quite long!!!)
plt.cmap = plt.cm.magma
plt.cmap.set_bad('k',1.)
plt.rcParams['image.cmap'] = 'magma'                   # Colormap.
plt.rcParams['image.interpolation'] = None
plt.rcParams['image.origin'] = 'lower'
plt.rcParams['font.family'] = "monospace"
plt.rcParams['font.monospace'] = 'DejaVu Sans Mono'

img=all_spec[:,:,expnum]
zeros=np.where(img &lt;= 0)     #Plot on a log scale, so set zero or negitive values to a small number 
img[zeros]=1E-10
fig,axs = plt.subplots()
f=axs.imshow(np.log10(img),vmin=0) #Plot image
plt.xlabel('x-pixel')
plt.ylabel('y-pixel')
axs.yaxis.set_major_locator(ticker.MultipleLocator(5))
axs.yaxis.set_minor_locator(ticker.MultipleLocator(1))
axs.xaxis.set_major_locator(ticker.MultipleLocator(50))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(10))
plt.axhline(y_lower, color = 'w', ls = 'dashed')
plt.axhline(y_upper, color = 'w', ls = 'dashed')
plt.title('2D NIRSpec Image of Exposure '+str(expnum))
fig.colorbar(f,label='Log$_{10}$ Electron counts',ax=axs)
plt.show()

</pre>
             </div>
            </div>
           </div>
          </div>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="visualizing-the-1d-spectral-data">
          <h1>
           Visualizing the 1D spectral data
           <a class="headerlink" href="#visualizing-the-1d-spectral-data" title="Permalink to this headline">
            #
           </a>
          </h1>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>fig,axs = plt.subplots()
f=plt.plot(wsdata_all,all_spec_1D[:,0], linewidth=2,zorder=0)  #overplot Transit model at data
plt.xlabel('Wavelength ($\mu$m)')
plt.ylabel('Flux (e-)')
axs.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(0.1))
plt.annotate('H$_2$O',xy=(3.0,42000))
plt.annotate('CO$_2$',xy=(4.2,42000))
plt.show()
</pre>
             </div>
            </div>
           </div>
          </div>
          <p>
           The CV3 test observed a lamp with a similar PSF as JWST will have, and has significant counts from
about 1.5 to 4.5
           <span class="math notranslate nohighlight">
            \(\mu\)
           </span>
           m.
          </p>
          <p>
           The cryogenic test chamber had CO
           <span class="math notranslate nohighlight">
            \(_2\)
           </span>
           and H
           <span class="math notranslate nohighlight">
            \(_2\)
           </span>
           O ice buildup on the window, which can be seen as spectral absorption features in the 2D spectra.
          </p>
          <section id="calculate-orbital-phase-and-a-separate-fine-grid-model-used-for-plotting-purposes">
           <h2>
            Calculate Orbital Phase and a separate fine grid model used for plotting purposes
            <a class="headerlink" href="#calculate-orbital-phase-and-a-separate-fine-grid-model-used-for-plotting-purposes" title="Permalink to this headline">
             #
            </a>
           </h2>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>#---------------------------------------------------------
#Calculate Orbital Phase
phase=(bjd-t0)/(per)  #phase in days relative to T0 ephemeris
phase=phase-np.fix(phase[number_of_images-1]) # Have current phase occur at value 0.0

t_fine = np.linspace(np.min(bjd), np.max(bjd), 1000) #times at which to calculate light curve
phase_fine=(t_fine-t0)/(per)  #phase in days relative to T0 ephemeris
phase_fine=phase_fine-np.fix(phase[number_of_images-1]) # Have current phase occur at value 0.0

b0=a_Rs * np.sqrt((np.sin(phase * 2* np.pi)) ** 2 + (np.cos(inc) * np.cos(phase * 2 * np.pi)) ** 2)
intransit=(b0-rp &lt; 1.0E0).nonzero()  #Select indicies between first and fourth contact
outtransit=(b0-rp &gt; 1.0E0).nonzero() #Select indicies out of transit
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="dealing-with-systematic-drift-on-the-detector">
          <h1>
           Dealing with Systematic Drift On the Detector
           <a class="headerlink" href="#dealing-with-systematic-drift-on-the-detector" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           The CV3 test assessed the stability of the instrument by introducing a large spatial jitter and drift. This resulted in a significant X,Y movement of the spectra on the 2D detector. While this bulk shift has been removed which aligns the spectra, intra- and inter- pixel sensitivities introduce flux variations which need to be removed. The jitter from the CV3 test was more than 30 mas, which is ~4X larger than the JWST stability requirement. Thus, in orbit these detector effects are expected to be significantly smaller, but they will still be present and will need to be modeled and removed from time series observations.
          </p>
          <p>
           The detector X, Y positions here were measured from cross-correlation of the 2D images (collapsing the spectra along one dimension first), and are saved in arrays
           <span class="math notranslate nohighlight">
            \(shx\)
           </span>
           and
           <span class="math notranslate nohighlight">
            \(shy\)
           </span>
           . These detending vectors would ideally be measured using the trace position values from the spectral extraction of each integration, as that could also accurately measure integration-to-integration how the spectra spatially changed on the detector.
          </p>
          <p>
           The detector shifts have original amplitudes near 0.2 pixels, though the vectors have had initial normalization. For detrending purposes, these arrays should have a mean of 0 and standard deviation of 1.0.
          </p>
          <p>
           A residual color-dependent trend with the LED lamp can also been seen in the CV3 data, which can be partly removed by scaling original common-mode lamp trend, which was measured using the CV3 white light curve.
          </p>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>shx_tmp=shx/np.mean(shx)-1.0E0       #Set Mean around 0.0
shx_detrend=shx_tmp/np.std(shx_tmp)  #Set standard deviation to 1.0
shy_tmp=shy/np.mean(shy)-1.0E0       #Set Mean around 0.0
shy_detrend=shy_tmp/np.std(shy_tmp)  #Set standard deviation to 1.0

cm=common_mode/np.mean(common_mode)-1.0E0
cm_detrend=cm/np.std(cm)

fig,axs = plt.subplots()
plt.plot(shx_detrend,label='X-possition')
plt.plot(shy_detrend,label='Y-possition')
plt.xlabel('Image Sequence Number')
plt.ylabel('Relative Detector Possition')
plt.title('Time-series Detrending Vectors')
axs.xaxis.set_major_locator(ticker.MultipleLocator(1000))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(100))
axs.yaxis.set_major_locator(ticker.MultipleLocator(0.5))
axs.yaxis.set_minor_locator(ticker.MultipleLocator(0.1))
plt.legend()
plt.show()
</pre>
             </div>
            </div>
           </div>
          </div>
          <section id="create-arrays-of-the-vectors-used-for-detrending">
           <h2>
            Create arrays of the vectors used for detrending.
            <a class="headerlink" href="#create-arrays-of-the-vectors-used-for-detrending" title="Permalink to this headline">
             #
            </a>
           </h2>
           <p>
            From Sing et al. 2019:  Systematic errors are often removed by a parameterized deterministic model, where the non-transit photometric trends are found to correlate with a number
            <span class="math notranslate nohighlight">
             \(n\)
            </span>
            of external parameters (or optical state vectors,
            <span class="math notranslate nohighlight">
             \(X\)
            </span>
            ). These parameters describe changes in the instrument or other external factors as a function of time during the observations, and are fit with a coefficient for each optical state parameter,
            <span class="math notranslate nohighlight">
             \(p_n\)
            </span>
            , to model and remove (or detrend) the photometric light curves.
           </p>
           <p>
            When including systematic trends, the total parameterized model of the flux measurements over time,
            <span class="math notranslate nohighlight">
             \(f(t)\)
            </span>
            , can be modeled as a combination of the theoretical transit model,
            <span class="math notranslate nohighlight">
             \(T(t,\theta)\)
            </span>
            (which depends upon the transit parameters
            <span class="math notranslate nohighlight">
             \(\theta\)
            </span>
            ), the total baseline flux detected from the star,
            <span class="math notranslate nohighlight">
             \(F_0\)
            </span>
            , and the systematics error model
            <span class="math notranslate nohighlight">
             \(S(x)\)
            </span>
            giving,
           </p>
           <p>
            <span class="math notranslate nohighlight">
             \(f(t) = T(t,\theta)\times F_0 \times S(x)\)
            </span>
            .
           </p>
           <p>
            We will use a linear model for the instrument systematic effects.
           </p>
           <p>
            <span class="math notranslate nohighlight">
             \(S(x)= p_1 x + p_2 y + p_3 x^2 + p_4 y^2 + p_5 x y + p_6 cm + p_7 \phi \)
            </span>
           </p>
           <p>
            <span class="math notranslate nohighlight">
             \(cm\)
            </span>
            is the common_mode trend, and
            <span class="math notranslate nohighlight">
             \(\phi\)
            </span>
            is a linear time trend which helps remove changing H
            <span class="math notranslate nohighlight">
             \(_2\)
            </span>
            O ice within the H
            <span class="math notranslate nohighlight">
             \(_2\)
            </span>
            O spectral feature.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>shx=shx_detrend
shy=shy_detrend
common_mode=cm_detrend

XX=np.array([shx,shy,shx**2,shy**2,shx*shy,common_mode,np.ones(number_of_images)])  #Detrending array without linear time trend
XX=np.transpose(XX)
XXX=np.array([shx,shy,shx**2,shy**2,shx*shy,common_mode,phase,np.ones(number_of_images)])  #Detrending array with with linear time trend
XXX=np.transpose(XXX)

</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            <strong>
             Linear Regression
            </strong>
            can be used to quickly determine the parameters
            <span class="math notranslate nohighlight">
             \(p_n\)
            </span>
            using the out-of-transit data.
           </p>
           <p>
            Here, we take a wavelength bin of the data (pixels 170 to 200) to make a time series.  The out-of-transit points are selected and a linear regression of
            <span class="math notranslate nohighlight">
             \(S(x)\)
            </span>
            is done to determine the optical state parameters
            <span class="math notranslate nohighlight">
             \(p_n\)
            </span>
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>pix1=170       # wavelength bin lower range
pix2=200       # wavelength bin upper range
y=np.sum(all_spec_1D[pix1:pix2,:],axis=0)    # flux over a selected wavelength bin

msize=plt.rcParams['lines.markersize'] ** 2.           # default marker size
plt.rcParams['figure.figsize'] = [10.0, 3.0]           # Figure dimensions

fig,axs = plt.subplots()
f=plt.plot(wsdata_all,all_spec_1D[:,0], linewidth=2,zorder=0)  #Plot Region of wavelength bin
plt.fill_between(wsdata_all[pix1:pix2],0,all_spec_1D[pix1:pix2,0],alpha=0.5)
plt.xlabel('Wavelength ($\mu$m)')
plt.ylabel('Flux (e-)')
plt.title('1D Extracted Spectrum')
axs.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(0.1))
plt.annotate('H$_2$O',xy=(3.0,42000))
plt.annotate('CO$_2$',xy=(4.2,42000))
plt.show()

fig,axs = plt.subplots()
plt.scatter(bjd,y/np.mean(y[outtransit]),label='$f(t)$ Data',zorder=1,s=msize*0.75,linewidth=1 ,alpha=0.4, marker='+',edgecolors='blue')
plt.xlabel('Barycentric Julian Date (days)')
plt.ylabel('Relative Flux')
plt.title('Time-series Transit Light Curve  $\lambda=$['+str(wsdata_all[pix1])+':'+str(wsdata_all[pix2])+'] $\mu$m')
plt.legend()
plt.show()

regressor = LinearRegression()
regressor.fit(XX[outtransit], y[outtransit]/np.mean(y[outtransit]))
print('Linear Regression Coefficients:')
print(regressor.coef_)
</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            The coefficients are on the order of ~10
            <span class="math notranslate nohighlight">
             \(^{-4}\)
            </span>
            so the trends have an amplitude on the order of 100’s of ppm.
           </p>
           <p>
            Visualize the fit
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>yfit=regressor.predict(XX)                         # Project the fit over the whole time series

plt.rcParams['figure.figsize'] = [10.0, 7.0]           # Figure dimensions
msize=plt.rcParams['lines.markersize'] ** 2.           # default marker size
plt.scatter(bjd,y/np.mean(y[outtransit]),label='$f(t)$ Data',zorder=1,s=msize*0.75,linewidth=1 ,alpha=0.5, marker='+',edgecolors='blue')
f=plt.plot(bjd,yfit,label='$S(x)$ Regression fit ', linewidth=2,color='orange',zorder=2,alpha=0.85)
plt.xlabel('Barycentric Julian Date (days)')
plt.ylabel('Relative Flux')
plt.title('Time-series Transit Light Curve  $\lambda=$['+str(wsdata_all[pix1])+':'+str(wsdata_all[pix2])+'] $\mu$m')
axs.xaxis.set_major_locator(ticker.MultipleLocator(0.01))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(0.005))
axs.yaxis.set_major_locator(ticker.MultipleLocator(0.002))
axs.yaxis.set_minor_locator(ticker.MultipleLocator(0.001))
yplot=y/np.mean(y[outtransit])
plt.ylim(yplot.min()*0.999, yplot.max()*1.001)
plt.xlim(bjd.min()-0.001, bjd.max()+0.001)
plt.legend(loc='lower left')
plt.show()
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="transit-and-limb-darkening-model-functions">
          <h1>
           Transit and Limb-Darkening Model Functions
           <a class="headerlink" href="#transit-and-limb-darkening-model-functions" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           Define a functions used by the fitting routines.
These which will take the transit and systematic parameters and create our full transit light curve model
          </p>
          <p>
           <span class="math notranslate nohighlight">
            \(model = T(t,\theta)\times F_0 \times S(x)\)
           </span>
          </p>
          <p>
           compares it to the data
          </p>
          <p>
           <span class="math notranslate nohighlight">
            \(y = f(t)\)
           </span>
          </p>
          <p>
           by returning the residuals
          </p>
          <p>
           <span class="math notranslate nohighlight">
            \((y-model)/(\sigma_y)\)
           </span>
          </p>
          <p>
           To calculate the transit model, here we use
           <strong>
            <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2002ApJ...580L.171M/abstract">
             Mandel and Agol (2002)
            </a>
           </strong>
           as coded in python by H. Wakeford (
           <strong>
            <a class="reference external" href="https://github.com/hrwakeford/ExoTiC-ISM">
             ExoTiC-ISM
            </a>
           </strong>
           ).
          </p>
          <p>
           To calculate the stellar limb-darkening, we use the procedure from Sing et al. (2010) which uses stellar models and fits for non-linear limb darkening coefficients, with a module as coded in python by H. Wakeford (
           <strong>
            <a class="reference external" href="https://github.com/hrwakeford/ExoTiC-ISM">
             ExoTiC-ISM
            </a>
           </strong>
           ).
          </p>
          <p>
           A new orbit is first calculated based on the system parameters of
           <span class="math notranslate nohighlight">
            \(a/R_{star}\)
           </span>
           , the cosine of the inclination
           <span class="math notranslate nohighlight">
            \(cos(i)\)
           </span>
           , and the orbital phase
           <span class="math notranslate nohighlight">
            \(\phi\)
           </span>
           .
The inputs are the orbit distance between the planet-star center
           <span class="math notranslate nohighlight">
            \(b\)
           </span>
           at each phase, limb-darkening parameters (
           <span class="math notranslate nohighlight">
            \(c_1,c_2,c_3,c_4\)
           </span>
           ), and the planet-to-star radius ratio
           <span class="math notranslate nohighlight">
            \(R_p/R_{star}\)
           </span>
           .
          </p>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>@custom_model
def nonlinear_limb_darkening(x, c0=0.0, c1=0.0, c2=0.0, c3=0.0):
    """
    Define non-linear limb darkening model with four parameters c0, c1, c2, c3.
    """
    model = (1. - (c0 * (1. - x ** (1. / 2)) + c1 * (1. - x ** (2. / 2)) + c2 * (1. - x ** (3. / 2)) + c3 *
                   (1. - x ** (4. / 2))))
    return model


@custom_model
def quadratic_limb_darkening(x, aLD=0.0, bLD=0.0):
    """
    Define linear limb darkening model with parameters aLD and bLD.
    """
    model = 1. - aLD * (1. - x) - bLD * (1. - x) ** (4. / 2.)
    return model


def limb_dark_fit(grating, wsdata, M_H, Teff, logg, dirsen, ld_model='1D'):
    """
    Calculates stellar limb-darkening coefficients for a given wavelength bin.

    Currently supports:
    HST STIS G750L, G750M, G430L gratings
    HST WFC3 UVIS/G280, IR/G102, IR/G141 grisms

    What is used for 1D models - Kurucz (?)
    Procedure from Sing et al. (2010, A&amp;A, 510, A21).
    Uses 3D limb darkening from Magic et al. (2015, A&amp;A, 573, 90).
    Uses photon FLUX Sum over (lambda*dlamba).
    :param grating: string; grating to use ('G430L','G750L','G750M', 'G280', 'G102', 'G141')
    :param wsdata: array; data wavelength solution
    :param M_H: float; stellar metallicity
    :param Teff: float; stellar effective temperature (K)
    :param logg: float; stellar gravity
    :param dirsen: string; path to main limb darkening directory
    :param ld_model: string; '1D' or '3D', makes choice between limb darkening models; default is 1D
    :return: uLD: float; linear limb darkening coefficient
    aLD, bLD: float; quadratic limb darkening coefficients
    cp1, cp2, cp3, cp4: float; three-parameter limb darkening coefficients
    c1, c2, c3, c4: float; non-linear limb-darkening coefficients
    """

    print('You are using the', str(ld_model), 'limb darkening models.')

    if ld_model == '1D':

        direc = os.path.join(dirsen, 'Kurucz')

        print('Current Directories Entered:')
        print('  ' + dirsen)
        print('  ' + direc)

        # Select metallicity
        M_H_Grid = np.array([-0.1, -0.2, -0.3, -0.5, -1.0, -1.5, -2.0, -2.5, -3.0, -3.5, -4.0, -4.5, -5.0, 0.0, 0.1, 0.2, 0.3, 0.5, 1.0])
        M_H_Grid_load = np.array([0, 1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 17, 20, 21, 22, 23, 24])
        optM = (abs(M_H - M_H_Grid)).argmin()
        MH_ind = M_H_Grid_load[optM]

        # Determine which model is to be used, by using the input metallicity M_H to figure out the file name we need
        direc = 'Kurucz'
        file_list = 'kuruczlist.sav'
        sav1 = readsav(os.path.join(dirsen, file_list))
        model = bytes.decode(sav1['li'][MH_ind])  # Convert object of type "byte" to "string"

        # Select Teff and subsequently logg
        Teff_Grid = np.array([3500, 3750, 4000, 4250, 4500, 4750, 5000, 5250, 5500, 5750, 6000, 6250, 6500])
        optT = (abs(Teff - Teff_Grid)).argmin()

        logg_Grid = np.array([4.0, 4.5, 5.0])
        optG = (abs(logg - logg_Grid)).argmin()

        if logg_Grid[optG] == 4.0:
            Teff_Grid_load = np.array([8, 19, 30, 41, 52, 63, 74, 85, 96, 107, 118, 129, 138])

        elif logg_Grid[optG] == 4.5:
            Teff_Grid_load = np.array([9, 20, 31, 42, 53, 64, 75, 86, 97, 108, 119, 129, 139])

        elif logg_Grid[optG] == 5.0:
            Teff_Grid_load = np.array([10, 21, 32, 43, 54, 65, 76, 87, 98, 109, 120, 130, 140])

        # Where in the model file is the section for the Teff we want? Index T_ind tells us that.
        T_ind = Teff_Grid_load[optT]
        header_rows = 3    #  How many rows in each section we ignore for the data reading
        data_rows = 1221   # How  many rows of data we read
        line_skip_data = (T_ind + 1) * header_rows + T_ind * data_rows   # Calculate how many lines in the model file we need to skip in order to get to the part we need (for the Teff we want).
        line_skip_header = T_ind * (data_rows + header_rows)

        # Read the header, in case we want to have the actual Teff, logg and M_H info.
        # headerinfo is a pandas object.
        headerinfo = pd.read_csv(os.path.join(dirsen, direc, model), delim_whitespace=True, header=None,
                                 skiprows=line_skip_header, nrows=1)

        Teff_model = headerinfo[1].values[0]
        logg_model = headerinfo[3].values[0]
        MH_model = headerinfo[6].values[0]
        MH_model = float(MH_model[1:-1])

        print('\nClosest values to your inputs:')
        print('Teff: ', Teff_model)
        print('M_H: ', MH_model)
        print('log(g): ', logg_model)

        # Read the data; data is a pandas object.
        data = pd.read_csv(os.path.join(dirsen, direc, model), delim_whitespace=True, header=None,
                              skiprows=line_skip_data, nrows=data_rows)

        # Unpack the data
        ws = data[0].values * 10   # Import wavelength data
        f0 = data[1].values / (ws * ws)
        f1 = data[2].values * f0 / 100000.
        f2 = data[3].values * f0 / 100000.
        f3 = data[4].values * f0 / 100000.
        f4 = data[5].values * f0 / 100000.
        f5 = data[6].values * f0 / 100000.
        f6 = data[7].values * f0 / 100000.
        f7 = data[8].values * f0 / 100000.
        f8 = data[9].values * f0 / 100000.
        f9 = data[10].values * f0 / 100000.
        f10 = data[11].values * f0 / 100000.
        f11 = data[12].values * f0 / 100000.
        f12 = data[13].values * f0 / 100000.
        f13 = data[14].values * f0 / 100000.
        f14 = data[15].values * f0 / 100000.
        f15 = data[16].values * f0 / 100000.
        f16 = data[17].values * f0 / 100000.

        # Make single big array of them
        fcalc = np.array([f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16])
        phot1 = np.zeros(fcalc.shape[0])

        # Define mu
        mu = np.array([1.000, .900, .800, .700, .600, .500, .400, .300, .250, .200, .150, .125, .100, .075, .050, .025, .010])

        # Passed on to main body of function are: ws, fcalc, phot1, mu

    elif ld_model == '3D':

        direc = os.path.join(dirsen, '3DGrid')

        print('Current Directories Entered:')
        print('  ' + dirsen)
        print('  ' + direc)

        # Select metallicity
        M_H_Grid = np.array([-3.0, -2.0, -1.0, 0.0])  # Available metallicity values in 3D models
        M_H_Grid_load = ['30', '20', '10', '00']  # The according identifiers to individual available M_H values
        optM = (abs(M_H - M_H_Grid)).argmin()  # Find index at which the closes M_H values from available values is to the input M_H.

        # Select Teff
        Teff_Grid = np.array([4000, 4500, 5000, 5500, 5777, 6000, 6500, 7000])  # Available Teff values in 3D models
        optT = (abs(Teff - Teff_Grid)).argmin()  # Find index at which the Teff values is, that is closest to input Teff.

        # Select logg, depending on Teff. If several logg possibilities are given for one Teff, pick the one that is
        # closest to user input (logg).

        if Teff_Grid[optT] == 4000:
            logg_Grid = np.array([1.5, 2.0, 2.5])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 4500:
            logg_Grid = np.array([2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 5000:
            logg_Grid = np.array([2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 5500:
            logg_Grid = np.array([3.0, 3.5, 4.0, 4.5, 5.0])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 5777:
            logg_Grid = np.array([4.4])
            optG = 0

        elif Teff_Grid[optT] == 6000:
            logg_Grid = np.array([3.5, 4.0, 4.5])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 6500:
            logg_Grid = np.array([4.0, 4.5])
            optG = (abs(logg - logg_Grid)).argmin()

        elif Teff_Grid[optT] == 7000:
            logg_Grid = np.array([4.5])
            optG = 0

        # Select Teff and Log g. Mtxt, Ttxt and Gtxt are then put together as string to load correct files.
        Mtxt = M_H_Grid_load[optM]
        Ttxt = "{:2.0f}".format(Teff_Grid[optT] / 100)
        if Teff_Grid[optT] == 5777:
            Ttxt = "{:4.0f}".format(Teff_Grid[optT])
        Gtxt = "{:2.0f}".format(logg_Grid[optG] * 10)

        #
        file = 'mmu_t' + Ttxt + 'g' + Gtxt + 'm' + Mtxt + 'v05.flx'
        print('Filename:', file)

        # Read data from IDL .sav file
        sav = readsav(os.path.join(direc, file))  # readsav reads an IDL .sav file
        ws = sav['mmd'].lam[0]  # read in wavelength
        flux = sav['mmd'].flx  # read in flux
        Teff_model = Teff_Grid[optT]
        logg_model = logg_Grid[optG]
        MH_model = str(M_H_Grid[optM])

        print('\nClosest values to your inputs:')
        print('Teff  : ', Teff_model)
        print('M_H   : ', MH_model)
        print('log(g): ', logg_model)

        f0 = flux[0]
        f1 = flux[1]
        f2 = flux[2]
        f3 = flux[3]
        f4 = flux[4]
        f5 = flux[5]
        f6 = flux[6]
        f7 = flux[7]
        f8 = flux[8]
        f9 = flux[9]
        f10 = flux[10]

        # Make single big array of them
        fcalc = np.array([f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10])
        phot1 = np.zeros(fcalc.shape[0])

        # Mu from grid
        # 0.00000    0.0100000    0.0500000     0.100000     0.200000     0.300000   0.500000     0.700000     0.800000     0.900000      1.00000
        mu = sav['mmd'].mu

        # Passed on to main body of function are: ws, fcalc, phot1, mu

    ### Load response function and interpolate onto kurucz model grid

    # FOR STIS
    if grating == 'G430L':
        sav = readsav(os.path.join(dirsen, 'G430L.STIS.sensitivity.sav'))  # wssens,sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 3

    if grating == 'G750M':
        sav = readsav(os.path.join(dirsen, 'G750M.STIS.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 0.554

    if grating == 'G750L':
        sav = readsav(os.path.join(dirsen, 'G750L.STIS.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 4.882

    # FOR WFC3
    if grating == 'G141':  # http://www.stsci.edu/hst/acs/analysis/reference_files/synphot_tables.html
        sav = readsav(os.path.join(dirsen, 'G141.WFC3.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 1

    if grating == 'G102':  # http://www.stsci.edu/hst/acs/analysis/reference_files/synphot_tables.html
        sav = readsav(os.path.join(dirsen, 'G141.WFC3.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 1

    if grating == 'G280':  # http://www.stsci.edu/hst/acs/analysis/reference_files/synphot_tables.html
        sav = readsav(os.path.join(dirsen, 'G280.WFC3.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 1

    # FOR JWST
    if grating == 'NIRSpecPrism':  # http://www.stsci.edu/hst/acs/analysis/reference_files/synphot_tables.html
        sav = readsav(os.path.join(dirsen, 'NIRSpec.prism.sensitivity.sav'))  # wssens, sensitivity
        wssens = sav['wssens']
        sensitivity = sav['sensitivity']
        wdel = 12


    widek = np.arange(len(wsdata))
    wsHST = wssens
    wsHST = np.concatenate((np.array([wsHST[0] - wdel - wdel, wsHST[0] - wdel]),
                            wsHST,
                            np.array([wsHST[len(wsHST) - 1] + wdel,
                                      wsHST[len(wsHST) - 1] + wdel + wdel])))

    respoutHST = sensitivity / np.max(sensitivity)
    respoutHST = np.concatenate((np.zeros(2), respoutHST, np.zeros(2)))
    inter_resp = interp1d(wsHST, respoutHST, bounds_error=False, fill_value=0)
    respout = inter_resp(ws)  # interpolate sensitivity curve onto model wavelength grid

    wsdata = np.concatenate((np.array([wsdata[0] - wdel - wdel, wsdata[0] - wdel]), wsdata,
                             np.array([wsdata[len(wsdata) - 1] + wdel, wsdata[len(wsdata) - 1] + wdel + wdel])))
    respwavebin = wsdata / wsdata * 0.0
    widek = widek + 2  # need to add two indicies to compensate for padding with 2 zeros
    respwavebin[widek] = 1.0
    data_resp = interp1d(wsdata, respwavebin, bounds_error=False, fill_value=0)
    reswavebinout = data_resp(ws)  # interpolate data onto model wavelength grid

    # Integrate over the spectra to make synthetic photometric points.
    for i in range(fcalc.shape[0]):  # Loop over spectra at diff angles
        fcal = fcalc[i, :]
        Tot = int_tabulated(ws, ws * respout * reswavebinout)
        phot1[i] = (int_tabulated(ws, ws * respout * reswavebinout * fcal, sort=True)) / Tot

    if ld_model == '1D':
        yall = phot1 / phot1[0]
    elif ld_model == '3D':
        yall = phot1 / phot1[10]

    Co = np.zeros((6, 4))   # NOT-REUSED

    A = [0.0, 0.0, 0.0, 0.0]  # c1, c2, c3, c4      # NOT-REUSED
    x = mu[1:]     # wavelength
    y = yall[1:]   # flux
    weights = x / x   # NOT-REUSED

    # Start fitting the different models
    fitter = LevMarLSQFitter()

    # Fit a four parameter non-linear limb darkening model and get fitted variables, c1, c2, c3, c4.
    corot_4_param = nonlinear_limb_darkening()
    corot_4_param = fitter(corot_4_param, x, y)
    c1, c2, c3, c4 = corot_4_param.parameters

    # Fit a three parameter non-linear limb darkening model and get fitted variables, cp2, cp3, cp4 (cp1 = 0).
    corot_3_param = nonlinear_limb_darkening()
    corot_3_param.c0.fixed = True  # 3 param is just 4 param with c0 = 0.0
    corot_3_param = fitter(corot_3_param, x, y)
    cp1, cp2, cp3, cp4 = corot_3_param.parameters

    # Fit a quadratic limb darkening model and get fitted parameters aLD and bLD.
    quadratic = quadratic_limb_darkening()
    quadratic = fitter(quadratic, x, y)
    aLD, bLD = quadratic.parameters

    # Fit a linear limb darkening model and get fitted variable uLD.
    linear = nonlinear_limb_darkening()
    linear.c0.fixed = True
    linear.c2.fixed = True
    linear.c3.fixed = True
    linear = fitter(linear, x, y)
    uLD = linear.c1.value

    print('\nLimb darkening parameters:')
    print("4param \t{:0.8f}\t{:0.8f}\t{:0.8f}\t{:0.8f}".format(c1, c2, c3, c4))
    print("3param \t{:0.8f}\t{:0.8f}\t{:0.8f}".format(cp2, cp3, cp4))
    print("Quad \t{:0.8f}\t{:0.8f}".format(aLD, bLD))
    print("Linear \t{:0.8f}".format(uLD))

    return uLD, c1, c2, c3, c4, cp1, cp2, cp3, cp4, aLD, bLD


def int_tabulated(X, F, sort=False):
    Xsegments = len(X) - 1

    # Sort vectors into ascending order.
    if not sort:
        ii = np.argsort(X)
        X = X[ii]
        F = F[ii]

    while (Xsegments % 4) != 0:
        Xsegments = Xsegments + 1

    Xmin = np.min(X)
    Xmax = np.max(X)

    # Uniform step size.
    h = (Xmax + 0.0 - Xmin) / Xsegments
    # Compute the interpolates at Xgrid.
    # x values of interpolates &gt;&gt; Xgrid = h * FINDGEN(Xsegments + 1L) + Xmin
    z = splev(h * np.arange(Xsegments + 1) + Xmin, splrep(X, F))

    # Compute the integral using the 5-point Newton-Cotes formula.
    ii = (np.arange((len(z) - 1) / 4, dtype=int) + 1) * 4

    return np.sum(2.0 * h * (7.0 * (z[ii - 4] + z[ii]) + 32.0 * (z[ii - 3] + z[ii - 1]) + 12.0 * z[ii - 2]) / 45.0)

</pre>
             </div>
            </div>
           </div>
          </div>
          <section id="now-define-the-transit-model-function">
           <h2>
            Now define the transit model function
            <a class="headerlink" href="#now-define-the-transit-model-function" title="Permalink to this headline">
             #
            </a>
           </h2>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>def occultnl(rl, c1, c2, c3, c4, b0):
    """
    MANDEL &amp; AGOL (2002) transit model.
    :param rl: float, transit depth (Rp/R*)
    :param c1: float, limb darkening parameter 1
    :param c2: float, limb darkening parameter 2
    :param c3: float, limb darkening parameter 3
    :param c4: float, limb darkening parameter 4
    :param b0: impact parameter in stellar radii
    :return: mulimb0: limb-darkened transit model, mulimbf: lightcurves for each component that you put in the model
    """
    mulimb0 = occultuniform(b0, rl)
    bt0 = b0
    fac = np.max(np.abs(mulimb0 - 1))
    if fac == 0:
        fac = 1e-6  # DKS edit

    omega = 4 * ((1 - c1 - c2 - c3 - c4) / 4 + c1 / 5 + c2 / 6 + c3 / 7 + c4 / 8)
    nb = len(b0)
    indx = np.where(mulimb0 != 1.0)[0]
    if len(indx) == 0:
        indx = -1
    mulimb = mulimb0[indx]
    mulimbf = np.zeros((5, nb))
    mulimbf[0, :] = mulimbf[0, :] + 1.
    mulimbf[1, :] = mulimbf[1, :] + 0.8
    mulimbf[2, :] = mulimbf[2, :] + 2 / 3
    mulimbf[3, :] = mulimbf[3, :] + 4 / 7
    mulimbf[4, :] = mulimbf[4, :] + 0.5
    nr = np.int64(2)
    dmumax = 1.0

    while (dmumax &gt; fac * 1.e-3) and (nr &lt;= 131072):
        #print(nr)
        mulimbp = mulimb
        nr = nr * 2
        dt = 0.5 * np.pi / nr
        t = dt * np.arange(nr + 1)
        th = t + 0.5 * dt
        r = np.sin(t)
        sig = np.sqrt(np.cos(th[nr - 1]))
        mulimbhalf = sig ** 3 * mulimb0[indx] / (1 - r[nr - 1])
        mulimb1 = sig ** 4 * mulimb0[indx] / (1 - r[nr - 1])
        mulimb3half = sig ** 5 * mulimb0[indx] / (1 - r[nr - 1])
        mulimb2 = sig ** 6 * mulimb0[indx] / (1 - r[nr - 1])
        for i in range(1, nr):
            mu = occultuniform(b0[indx] / r[i], rl / r[i])
            sig1 = np.sqrt(np.cos(th[i - 1]))
            sig2 = np.sqrt(np.cos(th[i]))
            mulimbhalf = mulimbhalf + r[i] ** 2 * mu * (sig1 ** 3 / (r[i] - r[i - 1]) - sig2 ** 3 / (r[i + 1] - r[i]))
            mulimb1 = mulimb1 + r[i] ** 2 * mu * (sig1 ** 4 / (r[i] - r[i - 1]) - sig2 ** 4 / (r[i + 1] - r[i]))
            mulimb3half = mulimb3half + r[i] ** 2 * mu * (sig1 ** 5 / (r[i] - r[i - 1]) - sig2 ** 5 / (r[i + 1] - r[i]))
            mulimb2 = mulimb2 + r[i] ** 2 * mu * (sig1 ** 6 / (r[i] - r[i - 1]) - sig2 ** 6 / (r[i + 1] - r[i]))

        mulimb = ((1 - c1 - c2 - c3 - c4) * mulimb0[
            indx] + c1 * mulimbhalf * dt + c2 * mulimb1 * dt + c3 * mulimb3half * dt + c4 * mulimb2 * dt) / omega
        ix1 = np.where(mulimb + mulimbp != 0.)[0]
        if len(ix1) == 0:
            ix1 = -1

        #print(ix1)
        # python cannot index on single values so you need to use atlest_1d for the below to work when mulimb is a single value
        dmumax = np.max(np.abs(np.atleast_1d(mulimb)[ix1] - np.atleast_1d(mulimbp)[ix1]) / (
                np.atleast_1d(mulimb)[ix1] + np.atleast_1d(mulimbp)[ix1]))

    mulimbf[0, indx] = np.atleast_1d(mulimb0)[indx]
    mulimbf[1, indx] = mulimbhalf * dt
    mulimbf[2, indx] = mulimb1 * dt
    mulimbf[3, indx] = mulimb3half * dt
    mulimbf[4, indx] = mulimb2 * dt
    np.atleast_1d(mulimb0)[indx] = mulimb
    b0 = bt0

    return mulimb0, mulimbf


def occultuniform(b0, w):
    """
    Compute the lightcurve for occultation of a uniform source without microlensing (Mandel &amp; Agol 2002).

    :param b0: array; impact parameter in units of stellar radii
    :param w: array; occulting star size in units of stellar radius
    :return: muo1: float; fraction of flux at each b0 for a uniform source
    """

    if np.abs(w - 0.5) &lt; 1.0e-3:
        w = 0.5

    nb = len(np.atleast_1d(b0))
    muo1 = np.zeros(nb)


    for i in range(nb):
        # substitute z=b0(i) to shorten expressions
        z = np.atleast_1d(b0)[i]
        #z = z.value    # stripping it of astropy units
        if z &gt;= 1+w:
            muo1[i] = 1.0
            continue

        if w &gt;= 1 and z &lt;= w-1:
            muo1[i] = 0.0
            continue

        if z &gt;= np.abs(1-w) and z &lt;= 1+w:
            kap1 = np.arccos(np.min(np.append((1 - w ** 2 + z ** 2) / 2 / z, 1.)))
            kap0 = np.arccos(np.min(np.append((w ** 2 + z ** 2 - 1) / 2 / w / z, 1.)))
            lambdae = w ** 2 * kap0 + kap1
            lambdae = (lambdae - 0.5 * np.sqrt(np.max(np.append(4. * z ** 2 - (1 + z ** 2 - w ** 2) ** 2, 0.)))) / np.pi
            muo1[i] = 1 - lambdae

        if z &lt;= 1-w:
            muo1[i] = 1 - w ** 2
            continue

    return muo1
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
          <section id="now-define-the-function-to-generate-the-transit-light-curve-and-compare-it-to-the-data">
           <h2>
            Now define the function to generate the transit light curve and compare it to the data
            <a class="headerlink" href="#now-define-the-function-to-generate-the-transit-light-curve-and-compare-it-to-the-data" title="Permalink to this headline">
             #
            </a>
           </h2>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>#Functions to call and calculate models
def residual(p,phase,x,y,err,c1, c2, c3, c4):
    #calculate new orbit
    b0=p['a_Rs'].value * np.sqrt((np.sin(phase * 2* np.pi)) ** 2 + (p['cosinc'].value * np.cos(phase * 2 * np.pi)) ** 2)
    #Select indicies between first and fourth contact
    intransit=(b0-p['rprs'].value &lt; 1.0E0).nonzero()
    #Make light curve model, set all values initially to 1.0
    light_curve=b0/b0
    mulimb0, mulimbf = occultnl(p['rprs'].value, c1, c2, c3, c4, b0[intransit])  #Madel and Agol
    light_curve[intransit]=mulimb0
    model=(light_curve)*p['f0'].value * (p['Fslope'].value*phase + p['xsh'].value*shx + p['x2sh'].value*shx**2. + p['ysh'].value*shy + p['y2sh'].value*shy**2. + p['xysh'].value*shy*shx +  p['comm'].value*common_mode + 1.0) # transit model is baseline flux X transit model X systematics model
    chi2now=np.sum((y-model)**2/err**2)
    res=np.std((y-model)/p['f0'].value)
    print("rprs: ",p['rprs'].value,"current chi^2=",chi2now,' scatter ',res,end="\r")
    return (y-model)/err
    #return np.sum((y-model)**2/err**2)
</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            A function is also defined to return just the transit model
            <span class="math notranslate nohighlight">
             \(T(t,\theta)\)
            </span>
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>def model_fine(p):  #Make Transit model with a fine grid for plotting purposes
    b0=p['a_Rs'].value * np.sqrt((np.sin(phase_fine * 2* np.pi)) ** 2 + (p['cosinc'].value * np.cos(phase_fine * 2 * np.pi)) ** 2)
    mulimb0, mulimbf = occultnl(p['rprs'].value, c1, c2, c3, c4, b0)  #Madel and Agol
    model_fine=mulimb0
    return model_fine
</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            Now add a transit model to the Example Light curve.  Here, we’ve compute the limb darkening coefficients, then use them in the transit light curve.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>wave1=wsdata_all[pix1]
wave2=wsdata_all[pix2]
bin_wave_index = ((wsdata_all &gt; wave1) &amp; (wsdata_all &lt;= wave2)).nonzero()
wsdata=wsdata_all[bin_wave_index]*1E4 # Select wavelength bin values (um=&gt; angstroms)

_uLD, c1, c2, c3, c4, _cp1, _cp2, _cp3, _cp4, aLD, bLD = limb_dark_fit(grating,wsdata, M_H, Teff,logg, limb_dark_directory, ld_model)

</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            Now run the transit model.
           </p>
           <p>
            The transit parameters such as inclination and
            <span class="math notranslate nohighlight">
             \(a/R_{star}\)
            </span>
            have been setup at the beginning of the notebook.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>#Run the Transit Model
rl = 0.0825     # Planet-to-star Radius Ratio

b0=a_Rs * np.sqrt((np.sin(phase * 2* np.pi)) ** 2 + (np.cos(inc) * np.cos(phase * 2 * np.pi)) ** 2)
intransit=(b0-rl &lt; 1.0E0).nonzero()  #Select indicies between first and fourth contact

mulimb0, mulimbf = occultnl(rl, c1, c2, c3, c4, b0)  #Mandel &amp; Agol non-linear limb darkened transit model
model=mulimb0*yfit 

#plot
plt.rcParams['figure.figsize'] = [10.0, 7.0]           # Figure dimensions
msize=plt.rcParams['lines.markersize'] ** 2.           # default marker size
fig=plt.figure(constrained_layout=True)
gs = fig.add_gridspec(3, 1,hspace=0.00, wspace=0.00)
ax1=fig.add_subplot(gs[0:2,:])
ax1.scatter(bjd,y/np.mean(y[outtransit]),label='$f(t)$ Data',zorder=1,s=msize*0.75,linewidth=1 ,alpha=0.5, marker='+',edgecolors='blue')
ax1.plot(bjd,model,label='$S(x)$ Regression fit ', linewidth=2,color='orange',zorder=2,alpha=0.85)
ax1.xaxis.set_ticklabels([])
plt.ylabel('Relative Flux')
plt.title('Time-series Transit Light Curve  $\lambda=$['+str(wsdata_all[pix1])+':'+str(wsdata_all[pix2])+'] $\mu$m')
ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.01))
ax1.xaxis.set_minor_locator(ticker.MultipleLocator(0.005))
ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.002))
ax1.yaxis.set_minor_locator(ticker.MultipleLocator(0.001))
yplot=y/np.mean(y[outtransit])
plt.ylim(yplot.min()*0.999, yplot.max()*1.001)
plt.xlim(bjd.min()-0.001, bjd.max()+0.001)
plt.legend()
fig.add_subplot(ax1)
#Residual
ax2=fig.add_subplot(gs[2,:])
ax2.scatter(bjd,1E6*(y/np.mean(y[outtransit])-model),label='$f(t)$ Data',zorder=1,s=msize*0.75,linewidth=1 ,alpha=0.5, marker='+',edgecolors='blue')
wsb, wsb_bin_edges,binnumber = stats.binned_statistic(bjd,1E6*(y/np.mean(y[outtransit])-model), bins=256)
plt.scatter(wsb_bin_edges[1:],wsb, linewidth=2,alpha=0.75,facecolors='orange',edgecolors='none', marker='o',zorder=25)
plt.xlabel('Barycentric Julian Date (days)')
plt.ylabel('Residual (ppm)')
ax2.xaxis.set_major_locator(ticker.MultipleLocator(0.01))
ax2.xaxis.set_minor_locator(ticker.MultipleLocator(0.005))
yplot=y/np.mean(y[outtransit])
plt.xlim(bjd.min()-0.001, bjd.max()+0.001)
fig.add_subplot(ax2)
plt.show()

#print chi^2 value
err=np.sqrt(y)/np.mean(y[outtransit])
print('Chi^2 = '+str(np.sum((y/np.mean(y[outtransit])-model)**2/err**2)))

print('Residual Standard Deviation : '+str(1E6*np.std((y/np.mean(y[outtransit])-model)))+' ppm')
print('256 Bin Standard Deviation  :'+str(np.std(wsb))+' ppm')
</pre>
              </div>
             </div>
            </div>
           </div>
           <p>
            Note that the model transit depth is a little too deep compared to the data. The planet radius needs to be smaller, and the parameter
            <span class="math notranslate nohighlight">
             \(rl\)
            </span>
            is closer to 0.08.  As an exercise you can re-run the above cell changing the planet radius to
            <span class="math notranslate nohighlight">
             \(rl\)
            </span>
            =0.0805 and compare the
            <span class="math notranslate nohighlight">
             \(\chi^2\)
            </span>
            value to the previous default value (
            <span class="math notranslate nohighlight">
             \(\chi^2\)
            </span>
            =9265.4 at
            <span class="math notranslate nohighlight">
             \(rl\)
            </span>
            = 0.0825).
           </p>
          </section>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="fit-transit-light-curves">
          <h1>
           FIT Transit Light Curves
           <a class="headerlink" href="#fit-transit-light-curves" title="Permalink to this headline">
            #
           </a>
          </h1>
          <p>
           Now we can fit each light curve, optimizing the fit parameters with a least-squares fit. Here a Levenberg-Marquart fit is used to find a
           <span class="math notranslate nohighlight">
            \(\chi^2\)
           </span>
           minimum and estimate uncertainties using the lmfit package (
           <a class="reference external" href="https://lmfit.github.io/lmfit-py/fitting.html">
            https://lmfit.github.io/lmfit-py/fitting.html
           </a>
           ).
          </p>
          <p>
           In practice, first we would fit the white light curve, which consists of summing over all of the wavelengths in the entire 1D spectra.  This can then be used to fit for the system parameters such as inclination and transit time, and then the spectroscopic channels are then fixed to these values as they are wavelength-independent.  However, the CV3 data required the overall variations of the lamp to be removed, which prevents our use of using this data for a white light curve analysis.  Here, we proceed to fitting for the spectroscopic light curve bins.
          </p>
          <p>
           The steps are as follows:
          </p>
          <div class="highlight-none notranslate">
           <div class="highlight">
            <pre><span></span>1) Wavelength Bin is selected

2) Limb-darkening coefficients are calculated from a stellar model for each bin. 

3) An initial linear regression is performed on the out-of-transit data to start the 
systematic fit parameters, this greatly speeds up the fit as those parameters start 
near their global minimum.

4) The fit is started, and some statistics are output during the minimization

5) Once the best-fit is found, a number of statistics are displayed 

6) Finally, several plots are generated which are stored as PDFs and the next bin is started.
</pre>
           </div>
          </div>
          <p>
           These steps are performed for each spectral bin.
          </p>
          <p>
           In this example, the planet radius is set to vary in the fit along with the baseline flux and instrument systematic parameters.
          </p>
          <section id="setup-wavelengths-to-fit-over">
           <h2>
            Setup Wavelengths to fit over
            <a class="headerlink" href="#setup-wavelengths-to-fit-over" title="Permalink to this headline">
             #
            </a>
           </h2>
           <p>
            The spectra must be binned in wavelength to get sufficient counts to reach ~100 ppm levels needed.
The spectra has significant counts from about pixel 100 to 400, we start at pixel
            <span class="math notranslate nohighlight">
             \(k0\)
            </span>
            and bin the spectra by
            <span class="math notranslate nohighlight">
             \(wk\)
            </span>
            pixels.
           </p>
           <p>
            Several arrays are also defined.
           </p>
           <div class="cell docutils container">
            <div class="cell_input docutils container">
             <div class="highlight-ipython3 notranslate">
              <div class="highlight">
               <pre><span></span>k0   = 113 #98   #100
kend = 392 #422
wk   = 15
number_of_bins = int((kend-k0)/wk)
wsd  = np.zeros((number_of_bins))
werr = np.zeros((number_of_bins))
rprs = np.zeros((number_of_bins))
rerr = np.zeros((number_of_bins))
sig_r = np.zeros((number_of_bins))
sig_w = np.zeros((number_of_bins))
beta  = np.zeros((number_of_bins))
depth = np.zeros((number_of_bins))
depth_err = np.zeros((number_of_bins))
</pre>
              </div>
             </div>
            </div>
           </div>
          </section>
          <section id="loop-over-wavelength-bins-fitting-each-lightcurve">
           <h2>
            Loop Over Wavelength Bins Fitting Each Lightcurve
            <a class="headerlink" href="#loop-over-wavelength-bins-fitting-each-lightcurve" title="Permalink to this headline">
             #
            </a>
           </h2>
           <section id="note-this-step-takes-considerable-time-to-complete-20-min-few-minutes-bin">
            <h3>
             Note this step takes considerable time to complete (~20 min, few minutes/bin)
             <a class="headerlink" href="#note-this-step-takes-considerable-time-to-complete-20-min-few-minutes-bin" title="Permalink to this headline">
              #
             </a>
            </h3>
            <p>
             Each wavelength bin is fit for the transit+systematics model. Various outputs including plots are saved.
Can skip to the next cells to load pre-computed results.
            </p>
            <div class="cell docutils container">
             <div class="cell_input docutils container">
              <div class="highlight-ipython3 notranslate">
               <div class="highlight">
                <pre><span></span>k=k0   #wavelength to start
#--------------------------------------------------------------------------
#Loop over wavelength bins and fit for each one
for bin in range(0,number_of_bins):
    
    #---------------------------------------------------------
    # Select wavelength bin
    wave1=wsdata_all[k]
    wave2=wsdata_all[k+wk]

    #Indicies to select for wavelgth bin
    bin_wave_index = ((wsdata_all &gt; wave1) &amp; (wsdata_all &lt;= wave2)).nonzero()

    #make light curve bin
    wave_bin_counts=np.sum(all_spec_1D[k+1:k+wk,:],axis=0) #Sum Wavelength pixels
    wave_bin_counts_err=np.sqrt(wave_bin_counts)           #adopt photon noise for errors
    #---------------------------------------------------------

    #---------------------------------------------------------
    # Calculate Limb Darkening

    wsdata=wsdata_all[bin_wave_index]*1E4 # Select wavelength bin values (um=&gt; angstroms)
    _uLD, c1, c2, c3, c4, _cp1, _cp2, _cp3, _cp4, aLD, bLD = limb_dark_fit(grating,wsdata, M_H, Teff,logg, limb_dark_directory, ld_model)

    print('\nc1 = {}'.format(c1))
    print('c2 = {}'.format(c2))
    print('c3 = {}'.format(c3))
    print('c4 = {}'.format(c4))
    print('')
    #u   = [c1,c2,c3,c4]      #limb darkening coefficients
    u   = [aLD,bLD]
    #---------------------------------------------------------

    #---------------------------------------------------------
    # Make initial model
    
    #Setup LMFIT
    x=bjd                    # X data
    y=wave_bin_counts        # Y data
    err=wave_bin_counts_err  # Y Error

    #Perform Quick Linear regression on out-of-transit data to obtain accurate starting Detector fit values
    if wave1 &gt; 2.7 and wave1 &lt; 3.45:
        regressor.fit(XXX[outtransit], y[outtransit]/np.mean(y[outtransit]))
    else:
        regressor.fit(XX[outtransit], y[outtransit]/np.mean(y[outtransit]))

    # create a set of Parameters for LMFIT https://lmfit.github.io/lmfit-py/parameters.html
    #class Parameter(name, value=None, vary=True, min=- inf, max=inf, expr=None, brute_step=None, user_data=None)¶
    #Set vary=0 to fix
    #Set vary=1 to fit
    p = lmfit.Parameters()  #object to store L-M fit Parameters           # Parameter Name
    p.add('cosinc'  , value=np.cos(inc)           ,vary=0)                # inclination, vary cos(inclin)
    p.add('rho_star', value=rho_star              ,vary=0)                # stellar density
    p.add('a_Rs'    , value=a_Rs                  ,vary=0)                # a/Rstar
    p.add('rprs'    , value=rp                     ,vary=1, min=0, max=1)  # planet-to-star radius ratio
    p.add('t0'      , value=t0                    ,vary=0)                # Transit T0
    p.add('f0'      , value=np.mean(y[outtransit]),vary=1, min=0)         # Baseline Flux
    p.add('ecc'     , value=ecc                   ,vary=0, min=0 , max=1) # eccentricity
    p.add('omega'   , value=omega                 ,vary=0)                # arguments of periatron
    #Turn on a linear slope in water feature to account for presumably changing H2O ice builtup on widow during cryogenic test
    if wave1 &gt; 2.7 and wave1 &lt; 3.45:
        p.add('Fslope', value=regressor.coef_[6]  ,vary=1)                # Orbital phase
    else:
        p.add('Fslope', value=0                   ,vary=0)                # Orbital phase
    p.add('xsh'     , value=regressor.coef_[0]    ,vary=1)                # Detector X-shift detrending
    p.add('ysh'     , value=regressor.coef_[1]    ,vary=1)                # Detector X-shift detrending
    p.add('x2sh'    , value=regressor.coef_[2]    ,vary=1)                # Detector X^2-shift detrending
    p.add('y2sh'    , value=regressor.coef_[3]    ,vary=1)                # Detector Y^2-shift detrending
    p.add('xysh'    , value=regressor.coef_[4]    ,vary=1)                # Detector X*Y detrending
    p.add('comm'    , value=regressor.coef_[5]    ,vary=1)                # Common-Mode detrending
    
    #--------------------------------------------------------------------------
    # Perform Minimization https://lmfit.github.io/lmfit-py/fitting.html
    # create Minimizer
    # mini = lmfit.Minimizer(residual, p, nan_policy='omit',fcn_args=(phase,x,y,err)
    print('')
    print('Fitting Bin',bin,' Wavelength =',np.mean(wsdata)/1E4, '  Range= [',wave1,':',wave2,']')

    #  solve with Levenberg-Marquardt using the
    result = lmfit.minimize(residual,params=p,args=(phase,x,y,err,c1, c2, c3, c4))
    #result = mini.minimize(method='emcee')

    print('')
    print('Re-Fitting Bin',bin,' Wavelength =',np.mean(wsdata)/1E4, '  Range= [',wave1,':',wave2,']')
    #--------------------------------------------------------------------------
    print("")
    print("redchi",result.redchi)
    print("chi2",result.chisqr)
    print("nfree",result.nfree)
    print("bic",result.bic)
    print("aic",result.aic)
    print("L-M FIT Variable")
    print(lmfit.fit_report(result.params))
    text_file = open(save_directory+'JWST_NIRSpec_Prism_fit_light_curve_bin'+str(bin)+'_statistics.txt', "w")
    n = text_file.write("\nredchi "+str(result.redchi))
    n = text_file.write("\nchi2   "+str(result.chisqr))
    n = text_file.write("\nnfree  "+str(result.nfree))
    n = text_file.write("\nbic    "+str(result.bic))
    n = text_file.write("\naic    "+str(result.aic))
    n = text_file.write(lmfit.fit_report(result.params))
    # file-output.py

    #Update with best-fit parameters
    p['rho_star'].value = result.params['rho_star'].value
    p['cosinc'].value   = result.params['cosinc'].value
    p['rprs'].value     = result.params['rprs'].value
    p['t0'].value       = result.params['t0'].value
    p['f0'].value       = result.params['f0'].value
    p['Fslope'].value   = result.params['Fslope'].value
    p['xsh'].value      = result.params['xsh'].value
    p['ysh'].value      = result.params['ysh'].value
    p['x2sh'].value     = result.params['x2sh'].value
    p['y2sh'].value     = result.params['y2sh'].value
    p['xysh'].value     = result.params['xysh'].value
    p['comm'].value     = result.params['comm'].value
    # Update Fit Spectra arrays
    wsd[bin]=np.mean(wsdata)/1E4
    werr[bin]=(wsdata.max()-wsdata.min())/2E4
    rprs[bin]=result.params['rprs'].value
    rerr[bin]=result.params['rprs'].stderr

    # Calculate Bestfit Model
    final_model=y-result.residual*err
    final_model_fine=model_fine(p)

    #More Stats
    resid=(y-final_model)/p['f0'].value
    residppm=1E6*(y-final_model)/p['f0'].value
    residerr=err/p['f0'].value
    sigma=np.std((y-final_model)/p['f0'].value)*1E6
    print("Residual standard deviation  (ppm) : ",1E6*np.std((y-final_model)/p['f0'].value))
    print("Photon noise                 (ppm) : ", (1/np.sqrt(p['f0'].value))*1E6     )
    print("Photon noise performance       (%) : ", (1/np.sqrt(p['f0'].value))*1E6 / (sigma) *100 )
    n = text_file.write("\nResidual standard deviation  (ppm) : "+str(1E6*np.std((y-final_model)/p['f0'].value)))
    n = text_file.write("\nPhoton noise                 (ppm) : "+str((1/np.sqrt(p['f0'].value))*1E6))
    n = text_file.write("\nPhoton noise performance       (%) : "+str((1/np.sqrt(p['f0'].value))*1E6 / (sigma) *100 ))
 
    #Measure Rednoise with Binning Technique
    sig0=np.std(resid)
    bins=number_of_images/binmeasure
    wsb, wsb_bin_edges,binnumber = stats.binned_statistic(bjd,resid, bins=bins)
    sig_binned=np.std(wsb)
    sigrednoise=np.sqrt(sig_binned**2-sig0**2/binmeasure)
    if np.isnan(sigrednoise) == True : sigrednoise=0   #if no rednoise detected, set to zero
    sigwhite   =np.sqrt(sig0**2-sigrednoise**2)
    sigrednoise=np.sqrt(sig_binned**2-sigwhite**2/binmeasure)
    if np.isnan(sigrednoise) == True : sigrednoise=0   #if no rednoise detected, set to zero
    beta[bin]=np.sqrt(sig0**2+binmeasure*sigrednoise**2)/sig0
    
    print("White noise                  (ppm) : ",1E6*sigwhite)
    print("Red noise                    (ppm) : ",1E6*sigrednoise)
    print("Transit depth measured error (ppm) : ",2E6*result.params['rprs'].value*result.params['rprs'].stderr)
    
    n = text_file.write("\nWhite noise                  (ppm) : "+str(1E6*sigwhite))
    n = text_file.write("\nRed noise                    (ppm) : "+str(1E6*sigrednoise))
    n = text_file.write("\nTransit depth measured error (ppm) : "+str(2E6*result.params['rprs'].value*result.params['rprs'].stderr))
    text_file.close()
    depth[bin]=1E6*result.params['rprs'].value**2
    depth_err[bin]=2E6*result.params['rprs'].value*result.params['rprs'].stderr

    sig_r[bin]=sigrednoise*1E6
    sig_w[bin]=sigwhite*1E6
    #--------------------------------------------------------------------------
    #---------------------------------------------------------
    #Write Fit Spectra to ascii file
    ascii_data = Table([wsd, werr, rprs, rerr,depth,depth_err,sig_w,sig_r,beta], names=['Wavelength Center (um)', 'Wavelength half-width (um)','Rp/Rs','Rp/Rs 1-sigma error','Transit Depth (ppm)','Transit Depth error','Sigma_white (ppm)','Sigma_red (ppm)','Beta Rednoise Inflation factor'])
    ascii.write(ascii_data, save_directory+'JWST_NIRSpec_Prism_fit_transmission_spectra.csv', format='csv',overwrite=True)
    #---------------------------------------------------------
    msize=plt.rcParams['lines.markersize'] ** 2. #default marker size
    #Plot data models
     
    #plot
    plt.rcParams['figure.figsize'] = [10.0, 7.0]           # Figure dimensions
    msize=plt.rcParams['lines.markersize'] ** 2.           # default marker size
    fig=plt.figure(constrained_layout=True)
    gs = fig.add_gridspec(3, 1,hspace=0.00, wspace=0.00)
    ax1=fig.add_subplot(gs[0:2,:])
    ax1.scatter(x,y/p['f0'].value,s=msize*0.75, linewidth=1,zorder=0,alpha=0.5, marker='+',edgecolors='blue')
    ax1.plot(x,final_model/p['f0'].value, linewidth=1,color='orange',alpha=0.8,zorder=15)  #overplot Transit model at data
    ax1.xaxis.set_ticklabels([])
    plt.ylabel('Relative Flux')
    plt.title('Time-series Transit Light Curve  $\lambda=$['+str(wave1)+':'+str(wave2)+'] $\mu$m')
    ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.01))
    ax1.xaxis.set_minor_locator(ticker.MultipleLocator(0.005))
    ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.002))
    ax1.yaxis.set_minor_locator(ticker.MultipleLocator(0.001))
    yplot=y/np.mean(y[outtransit])
    plt.ylim(yplot.min()*0.999, yplot.max()*1.001)
    plt.xlim(bjd.min()-0.001, bjd.max()+0.001)
    fig.add_subplot(ax1)
    #Residual
    ax2=fig.add_subplot(gs[2,:])
    ax2.scatter(x,residppm, s=msize*0.75,linewidth=1 ,alpha=0.5, marker='+',edgecolors='blue',zorder=0)  #overplot Transit model at data
    wsb, wsb_bin_edges,binnumber = stats.binned_statistic(bjd,residppm, bins=256)
    plt.scatter(wsb_bin_edges[1:],wsb, linewidth=2,alpha=0.75,facecolors='orange',edgecolors='none', marker='o',zorder=25)
    plt.xlabel('Barycentric Julian Date (days)')
    plt.ylabel('Residual (ppm)')
    plt.plot([bjd.min(),bjd.max()],[0,0],color='black',zorder=10)
    plt.plot([bjd.min(),bjd.max()],[sigma,sigma],linestyle='--',color='black',zorder=15)
    plt.plot([bjd.min(),bjd.max()],[-sigma,-sigma],linestyle='--',color='black',zorder=20)
    ax2.xaxis.set_major_locator(ticker.MultipleLocator(0.01))
    ax2.xaxis.set_minor_locator(ticker.MultipleLocator(0.005))
    yplot=y/np.mean(y[outtransit])
    plt.xlim(bjd.min()-0.001, bjd.max()+0.001)
    fig.add_subplot(ax2)
    #save
    pp = PdfPages(save_directory+'JWST_NIRSpec_Prism_fit_light_curve_bin'+str(bin)+'_lightcurve.pdf')
    plt.savefig(pp,format='pdf')
    pp.close()
    plt.clf()   
    #--------------------------------------------------------------------------
    #plot systematic corrected light curve
    b0=p['a_Rs'].value * np.sqrt((np.sin(phase * 2* np.pi)) ** 2 + (p['cosinc'].value * np.cos(phase * 2 * np.pi)) ** 2)
    intransit=(b0-p['rprs'].value &lt; 1.0E0).nonzero()
    light_curve=b0/b0
    mulimb0, mulimbf = occultnl(p['rprs'].value, c1, c2, c3, c4, b0[intransit])  #Madel and Agol
    light_curve[intransit]=mulimb0
    fig,axs = plt.subplots()
    plt.scatter(x,light_curve+resid,s=msize*0.75, linewidth=1,zorder=0,alpha=0.5, marker='+',edgecolors='blue')
    plt.xlabel('BJD')
    plt.ylabel('Relative Flux')
    plt.plot(x,light_curve, linewidth=2,color='orange',alpha=0.8,zorder=15)  #overplot Transit model at data
    pp = PdfPages(save_directory+'JWST_NIRSpec_Prism_fit_light_curve_bin'+str(bin)+'_corrected.pdf')
    plt.savefig(pp,format='pdf')
    pp.close()
    plt.clf()
    plt.close('all') #close all figures
    #--------------------------------------------------------------------------
    k=k+wk  #step wavelength index to next bin
    
    print('** Can Now View Output PDFs in ',save_directory)
</pre>
               </div>
              </div>
             </div>
            </div>
           </section>
          </section>
         </section>
         <section class="tex2jax_ignore mathjax_ignore" id="plot-measured-exoplanet-transmission-spectrum-vs-injected">
          <h1>
           Plot Measured Exoplanet Transmission Spectrum vs Injected
           <a class="headerlink" href="#plot-measured-exoplanet-transmission-spectrum-vs-injected" title="Permalink to this headline">
            #
           </a>
          </h1>
          <div class="cell docutils container">
           <div class="cell_input docutils container">
            <div class="highlight-ipython3 notranslate">
             <div class="highlight">
              <pre><span></span>#--------------------------------------------------------------------------
#Load Injected Transmission spectra to compare with recovered value

#Download Injected Spectra
fn_tm  = download_file('https://data.science.stsci.edu/redirect/JWST/jwst-data_analysis_tools/transit_spectroscopy_notebook/trans-iso_GJ-0436_0669.0_+0.0_0.56_0001_0.00_model.NIRSpec_PRISM.txt')
destld = shutil.move(fn_tm,save_directory+'trans-iso_GJ-0436_0669.0_+0.0_0.56_0001_0.00_model.NIRSpec_PRISM.txt')        

f = open(save_directory+'trans-iso_GJ-0436_0669.0_+0.0_0.56_0001_0.00_model.NIRSpec_PRISM.txt', 'r')
data = np.genfromtxt(f, delimiter='   ')
model_ws   = data[:,0]
model_spec = data[:,1]

#Read fit transit depths
data = ascii.read(save_directory+'JWST_NIRSpec_Prism_fit_transmission_spectra.csv', format='csv')
wsd  = data['Wavelength Center (um)']
werr = data['Wavelength half-width (um)']
rprs = data['Rp/Rs']
rerr = data['Rp/Rs 1-sigma error']
beta = data['Beta Rednoise Inflation factor']

#plot
fig,axs = plt.subplots()
plt.plot(model_ws,model_spec**2*1E6, linewidth=2,zorder=0,color='blue',label='Injected Spectra')  #overplot Transit model at data
plt.errorbar(wsd,rprs**2*1E6,xerr=werr,yerr=2*rerr*rprs*1E6*beta, fmt='o',zorder=5,alpha=0.4,color='orange',label='Recovered Spectra with $\sigma_r$')
plt.errorbar(wsd,rprs**2*1E6,xerr=werr,yerr=2*rerr*rprs*1E6, fmt='o',zorder=10,color='orange',label='Recovered Spectra')
plt.xlabel('Wavelength ($\mu$m)')
plt.ylabel('Transit Depth ($R_p/R_s$)$^2$ (ppm)')
axs.yaxis.set_major_locator(ticker.MultipleLocator(200))
axs.yaxis.set_minor_locator(ticker.MultipleLocator(100))
axs.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
axs.xaxis.set_minor_locator(ticker.MultipleLocator(0.1))
axs.text(3.3,6850,'CH$_4$')
axs.text(4.25,6700,'CO')
axs.text(2.3,6750,'CH$_4$')
axs.text(2.75,6550,'H$_2$O')
plt.ylim(5700,7000)
plt.xlim(0.9,5.25)
plt.legend(loc='lower right')    
plt.show()
plt.clf()
</pre>
             </div>
            </div>
           </div>
          </div>
          <p>
           By and large, the injected transit depths are well recovered across the spectra, with features such as H
           <span class="math notranslate nohighlight">
            \(_2\)
           </span>
           O and CH
           <span class="math notranslate nohighlight">
            \(_4\)
           </span>
           easily detected. There is a bit of an offset in data-points long-ward of 3.5
           <span class="math notranslate nohighlight">
            \(\mu\)
           </span>
           m that could perhaps be due to changes in CO
           <span class="math notranslate nohighlight">
            \(_2\)
           </span>
           or H
           <span class="math notranslate nohighlight">
            \(_2\)
           </span>
           O absorption features from ice built up on the cryogenic window during the CV3 test. These wavelengths show some increases in time correlated noise (
           <span class="math notranslate nohighlight">
            \(\sigma_r\)
           </span>
           ), which has been measured here, and the errors in the plot also show the transit depths with this error included.
          </p>
          <p>
           The precisions from the ground-based test are very encouraging, with the best measured bin (which occurs in a clean part of the spectrum with high count rates) achieving near-photon limited transit depths measured to about 30 ppm in only 2 hours of data, and with minimal time correlated noise (
           <span class="math notranslate nohighlight">
            \(\sigma_r\)
           </span>
           ).
          </p>
          <p>
           For more robust error estimates, in practice the least-squares minimization performed here would be replaced by an MCMC routine.  In addition, with actual transit data, the transit fit parameters (e.g.
           <span class="math notranslate nohighlight">
            \(i\)
           </span>
           ,
           <span class="math notranslate nohighlight">
            \(a/R_{star}\)
           </span>
           , T
           <span class="math notranslate nohighlight">
            \(_0\)
           </span>
           ) would also have to be first fit as well, as they can/will differ from literature estimates in high precision transit light curves as JWST will provide.
          </p>
         </section>
         <script type="text/x-thebe-config">
          {
        requestKernel: true,
        binderOptions: {
            repo: "spacetelescope/jdat_notebooks",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/transit_spectroscopy_notebook"
        },
        predefinedOutput: true
    }
         </script>
         <script>
          kernelName = 'python3'
         </script>
        </div>
       </main>
       <footer class="footer-article noprint">
        <!-- Previous / next buttons -->
        <div class="prev-next-area">
         <a class="left-prev" href="../mos-spectroscopy/MOSspec_sv06_revised.html" id="prev-link" title="previous page">
          <i class="fas fa-angle-left">
          </i>
          <div class="prev-next-info">
           <p class="prev-next-subtitle">
            previous
           </p>
           <p class="prev-next-title">
            MOS Spectroscopy of Extragalactic Field
           </p>
          </div>
         </a>
        </div>
       </footer>
      </div>
     </div>
     <div class="footer-content row">
      <footer class="col footer">
       <p>
        By STScI
        <br/>
        © Copyright 2022.
        <br/>
       </p>
      </footer>
     </div>
    </div>
   </div>
  </div>
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  </script>
 </body>
</html>